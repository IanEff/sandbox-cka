/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/tiny-emitter/index.js
var require_tiny_emitter = __commonJS({
  "node_modules/tiny-emitter/index.js"(exports, module2) {
    function E() {
    }
    E.prototype = {
      on: function(name, callback, ctx) {
        var e = this.e || (this.e = {});
        (e[name] || (e[name] = [])).push({
          fn: callback,
          ctx
        });
        return this;
      },
      once: function(name, callback, ctx) {
        var self = this;
        function listener() {
          self.off(name, listener);
          callback.apply(ctx, arguments);
        }
        ;
        listener._ = callback;
        return this.on(name, listener, ctx);
      },
      emit: function(name) {
        var data = [].slice.call(arguments, 1);
        var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
        var i = 0;
        var len = evtArr.length;
        for (i; i < len; i++) {
          evtArr[i].fn.apply(evtArr[i].ctx, data);
        }
        return this;
      },
      off: function(name, callback) {
        var e = this.e || (this.e = {});
        var evts = e[name];
        var liveEvents = [];
        if (evts && callback) {
          for (var i = 0, len = evts.length; i < len; i++) {
            if (evts[i].fn !== callback && evts[i].fn._ !== callback)
              liveEvents.push(evts[i]);
          }
        }
        liveEvents.length ? e[name] = liveEvents : delete e[name];
        return this;
      }
    };
    module2.exports = E;
    module2.exports.TinyEmitter = E;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TWPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return (
    /** @type {T & S} */
    tar
  );
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function exclude_internal_props(props) {
  const result = {};
  for (const k in props)
    if (k[0] !== "$")
      result[k] = props[k];
  return result;
}
function compute_rest_props(props, keys) {
  const rest = {};
  keys = new Set(keys);
  for (const k in props)
    if (!keys.has(k) && k[0] !== "$")
      rest[k] = props[k];
  return rest;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    var _a;
    return (_a = this._observer) != null ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) == null ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
var always_set_through_set_attribute = ["width", "height"];
function set_attributes(node, attributes) {
  const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
  for (const key in attributes) {
    if (attributes[key] == null) {
      node.removeAttribute(key);
    } else if (key === "style") {
      node.style.cssText = attributes[key];
    } else if (key === "__value") {
      node.value = node[key] = attributes[key];
    } else if (descriptors[key] && descriptors[key].set && always_set_through_set_attribute.indexOf(key) === -1) {
      node[key] = attributes[key];
    } else {
      attr(node, key, attributes[key]);
    }
  }
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = /** @type {string} */
  data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function toggle_class(element2, name, toggle) {
  element2.classList.toggle(name, !!toggle);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  return new CustomEvent(type, { detail, bubbles, cancelable });
}
var HtmlTag = class {
  constructor(is_svg = false) {
    /**
     * @private
     * @default false
     */
    __publicField(this, "is_svg", false);
    /** parent for creating node */
    __publicField(this, "e");
    /** html tag nodes */
    __publicField(this, "n");
    /** target */
    __publicField(this, "t");
    /** anchor */
    __publicField(this, "a");
    this.is_svg = is_svg;
    this.e = this.n = null;
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  c(html) {
    this.h(html);
  }
  /**
   * @param {string} html
   * @param {HTMLElement | SVGElement} target
   * @param {HTMLElement | SVGElement} anchor
   * @returns {void}
   */
  m(html, target, anchor = null) {
    if (!this.e) {
      if (this.is_svg)
        this.e = svg_element(
          /** @type {keyof SVGElementTagNameMap} */
          target.nodeName
        );
      else
        this.e = element(
          /** @type {keyof HTMLElementTagNameMap} */
          target.nodeType === 11 ? "TEMPLATE" : target.nodeName
        );
      this.t = target.tagName !== "TEMPLATE" ? target : (
        /** @type {HTMLTemplateElement} */
        target.content
      );
      this.c(html);
    }
    this.i(anchor);
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  h(html) {
    this.e.innerHTML = html;
    this.n = Array.from(
      this.e.nodeName === "TEMPLATE" ? this.e.content.childNodes : this.e.childNodes
    );
  }
  /**
   * @returns {void} */
  i(anchor) {
    for (let i = 0; i < this.n.length; i += 1) {
      insert(this.t, this.n[i], anchor);
    }
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  p(html) {
    this.d();
    this.h(html);
    this.i(this.a);
  }
  /**
   * @returns {void} */
  d() {
    this.n.forEach(detach);
  }
};
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(
        /** @type {string} */
        type,
        detail,
        { cancelable }
      );
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block5, next, get_context) {
  let o = old_blocks.length;
  let n = list.length;
  let i = o;
  const old_indexes = {};
  while (i--)
    old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i = n;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block5(key, child_ctx);
      block.c();
    } else if (dynamic) {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n--;
  }
  while (o && n) {
    const new_block = new_blocks[n - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o--;
      n--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n)
    insert2(new_blocks[n - 1]);
  run_all(updates);
  return new_blocks;
}

// node_modules/svelte/src/runtime/internal/spread.js
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n = updates[i];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function bind(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance11, create_fragment11, not_equal, props, append_styles2 = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance11 ? instance11(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment11 ? create_fragment11($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot2 = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create() {
                node = element("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot2(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key].attribute || key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a;
      if (this.$$r)
        return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a = this.$$c) == null ? void 0 : _a.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn && this.$$c) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  var _a;
  const type = (_a = props_definition[prop]) == null ? void 0 : _a.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// src/task-handler.ts
var import_child_process = require("child_process");
var import_util = require("util");

// node_modules/neverthrow/dist/index.es.js
var defaultErrorConfig = {
  withStackTrace: false
};
var createNeverThrowError = (message, result, config = defaultErrorConfig) => {
  const data = result.isOk() ? { type: "Ok", value: result.value } : { type: "Err", value: result.error };
  const maybeStack = config.withStackTrace ? new Error().stack : void 0;
  return {
    data,
    message,
    stack: maybeStack
  };
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
var ResultAsync = class {
  constructor(res) {
    this._promise = res;
  }
  static fromSafePromise(promise) {
    const newPromise = promise.then((value) => new Ok(value));
    return new ResultAsync(newPromise);
  }
  static fromPromise(promise, errorFn) {
    const newPromise = promise.then((value) => new Ok(value)).catch((e) => new Err(errorFn(e)));
    return new ResultAsync(newPromise);
  }
  static combine(asyncResultList) {
    return combineResultAsyncList(asyncResultList);
  }
  static combineWithAllErrors(asyncResultList) {
    return combineResultAsyncListWithAllErrors(asyncResultList);
  }
  map(f) {
    return new ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isErr()) {
        return new Err(res.error);
      }
      return new Ok(yield f(res.value));
    })));
  }
  mapErr(f) {
    return new ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isOk()) {
        return new Ok(res.value);
      }
      return new Err(yield f(res.error));
    })));
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  andThen(f) {
    return new ResultAsync(this._promise.then((res) => {
      if (res.isErr()) {
        return new Err(res.error);
      }
      const newValue = f(res.value);
      return newValue instanceof ResultAsync ? newValue._promise : newValue;
    }));
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  orElse(f) {
    return new ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {
      if (res.isErr()) {
        return f(res.error);
      }
      return new Ok(res.value);
    })));
  }
  match(ok2, _err) {
    return this._promise.then((res) => res.match(ok2, _err));
  }
  unwrapOr(t) {
    return this._promise.then((res) => res.unwrapOr(t));
  }
  /**
   * Emulates Rust's `?` operator in `safeTry`'s body. See also `safeTry`.
   */
  safeUnwrap() {
    return __asyncGenerator(this, arguments, function* safeUnwrap_1() {
      return yield __await(yield __await(yield* __asyncDelegator(__asyncValues(yield __await(this._promise.then((res) => res.safeUnwrap()))))));
    });
  }
  // Makes ResultAsync implement PromiseLike<Result>
  then(successCallback, failureCallback) {
    return this._promise.then(successCallback, failureCallback);
  }
};
var errAsync = (err2) => new ResultAsync(Promise.resolve(new Err(err2)));
var fromPromise = ResultAsync.fromPromise;
var fromSafePromise = ResultAsync.fromSafePromise;
var appendValueToEndOfList = (value) => (list) => [...list, value];
var combineResultList = (resultList) => resultList.reduce((acc, result) => acc.isOk() ? result.isErr() ? err(result.error) : acc.map(appendValueToEndOfList(result.value)) : acc, ok([]));
var combineResultAsyncList = (asyncResultList) => ResultAsync.fromSafePromise(Promise.all(asyncResultList)).andThen(combineResultList);
var combineResultListWithAllErrors = (resultList) => resultList.reduce((acc, result) => result.isErr() ? acc.isErr() ? err([...acc.error, result.error]) : err([result.error]) : acc.isErr() ? acc : ok([...acc.value, result.value]), ok([]));
var combineResultAsyncListWithAllErrors = (asyncResultList) => ResultAsync.fromSafePromise(Promise.all(asyncResultList)).andThen(combineResultListWithAllErrors);
var Result;
(function(Result2) {
  function fromThrowable2(fn, errorFn) {
    return (...args) => {
      try {
        const result = fn(...args);
        return ok(result);
      } catch (e) {
        return err(errorFn ? errorFn(e) : e);
      }
    };
  }
  Result2.fromThrowable = fromThrowable2;
  function combine(resultList) {
    return combineResultList(resultList);
  }
  Result2.combine = combine;
  function combineWithAllErrors(resultList) {
    return combineResultListWithAllErrors(resultList);
  }
  Result2.combineWithAllErrors = combineWithAllErrors;
})(Result || (Result = {}));
var ok = (value) => new Ok(value);
var err = (err2) => new Err(err2);
var Ok = class {
  constructor(value) {
    this.value = value;
  }
  isOk() {
    return true;
  }
  isErr() {
    return !this.isOk();
  }
  map(f) {
    return ok(f(this.value));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  mapErr(_f) {
    return ok(this.value);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  andThen(f) {
    return f(this.value);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  orElse(_f) {
    return ok(this.value);
  }
  asyncAndThen(f) {
    return f(this.value);
  }
  asyncMap(f) {
    return ResultAsync.fromSafePromise(f(this.value));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  unwrapOr(_v) {
    return this.value;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  match(ok2, _err) {
    return ok2(this.value);
  }
  safeUnwrap() {
    const value = this.value;
    return function* () {
      return value;
    }();
  }
  _unsafeUnwrap(_) {
    return this.value;
  }
  _unsafeUnwrapErr(config) {
    throw createNeverThrowError("Called `_unsafeUnwrapErr` on an Ok", this, config);
  }
};
var Err = class {
  constructor(error) {
    this.error = error;
  }
  isOk() {
    return false;
  }
  isErr() {
    return !this.isOk();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  map(_f) {
    return err(this.error);
  }
  mapErr(f) {
    return err(f(this.error));
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  andThen(_f) {
    return err(this.error);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  orElse(f) {
    return f(this.error);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  asyncAndThen(_f) {
    return errAsync(this.error);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  asyncMap(_f) {
    return errAsync(this.error);
  }
  unwrapOr(v) {
    return v;
  }
  match(_ok, err2) {
    return err2(this.error);
  }
  safeUnwrap() {
    const error = this.error;
    return function* () {
      yield err(error);
      throw new Error("Do not use this generator out of `safeTry`");
    }();
  }
  _unsafeUnwrap(config) {
    throw createNeverThrowError("Called `_unsafeUnwrap` on an Err", this, config);
  }
  _unsafeUnwrapErr(_) {
    return this.error;
  }
};
var fromThrowable = Result.fromThrowable;

// src/task-handler.ts
var import_obsidian = require("obsidian");

// src/util.ts
var TWPluginLogger = class {
  constructor(debugMode = false) {
    this.setDebugMode(debugMode);
  }
  setDebugMode(debugMode) {
    if (debugMode) {
      this.debug_log = this._internalLog;
    } else {
      this.debug_log = () => {
      };
    }
  }
  _internalLog(msg, ...optionalParams) {
    console.log(msg, ...optionalParams);
  }
  debug_log(msg, ...optionalParams) {
  }
  error_log(msg, ...optionalParams) {
    console.error(msg, ...optionalParams);
  }
};
function sanitizeSingleArgument(input) {
  return `"${input.replace(/"/g, '\\"')}"`;
}
function sanitize(input) {
  return sanitizeArguments(userArguments(input));
}
function sanitizeArguments(userArguments2) {
  return userArguments2.map((arg) => `"${arg.replace(/"/g, '\\"')}"`).join(" ");
}
function limitString(string) {
  return string.length > 30 ? string.substring(0, 30) + "..." : string;
}
function hexToHSL(Hex) {
  let r, g, b;
  if (Hex.length == 4) {
    r = "0x" + Hex[1] + Hex[1];
    g = "0x" + Hex[2] + Hex[2];
    b = "0x" + Hex[3] + Hex[3];
  } else if (Hex.length == 7) {
    r = "0x" + Hex[1] + Hex[2];
    g = "0x" + Hex[3] + Hex[4];
    b = "0x" + Hex[5] + Hex[6];
  }
  r = r / 255;
  g = g / 255;
  b = b / 255;
  const cmin = Math.min(r, g, b), cmax = Math.max(r, g, b), delta = cmax - cmin;
  let h = 0, s = 0, l = 0;
  if (delta == 0)
    h = 0;
  else if (cmax == r)
    h = (g - b) / delta % 6;
  else if (cmax == g)
    h = (b - r) / delta + 2;
  else
    h = (r - g) / delta + 4;
  h = Math.round(h * 60);
  if (h < 0)
    h += 360;
  l = (cmax + cmin) / 2;
  s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
  s = +(s * 100).toFixed(1);
  l = +(l * 100).toFixed(1);
  return [h, s, l];
}
var hexToHSLCache = /* @__PURE__ */ new Map();
function memoizedHexToHSL(hex) {
  const cachedResult = hexToHSLCache.get(hex);
  if (cachedResult !== void 0)
    return cachedResult;
  const hsl = hexToHSL(hex);
  hexToHSLCache.set(hex, hsl);
  return hsl;
}
function hslLerp(a, b, t) {
  const h = a[0] + (b[0] - a[0]) * t;
  const s = a[1] + (b[1] - a[1]) * t;
  const l = a[2] + (b[2] - a[2]) * t;
  return [h, s, l];
}
function threeColorHslLerp(a, b, c, t) {
  const clampedT = Math.min(1, Math.max(0, t));
  if (clampedT < 0.5) {
    return hslLerp(a, b, clampedT * 2);
  } else {
    return hslLerp(b, c, (clampedT - 0.5) * 2);
  }
}
function shortUuid(uuid) {
  return uuid.split("-", 1)[0];
}
function userArguments(input) {
  const args = [];
  let current = "";
  let quoted = false;
  let escaped = false;
  for (let i = 0; i < input.length; i++) {
    const char = input[i];
    if ((char === " " || char === "\n") && !quoted && !escaped) {
      args.push(current);
      current = "";
    } else if (char === '"' && !escaped) {
      quoted = !quoted;
    } else if (char === "\\" && !escaped) {
      escaped = true;
    } else if (char !== '"' && escaped) {
      current += "\\" + char;
      escaped = false;
    } else {
      current += char;
      escaped = false;
    }
  }
  if (current !== "") {
    args.push(current);
  }
  return args;
}
function clearUriCache() {
  uriCache.clear();
}
var uriCache = /* @__PURE__ */ new Map();
function matchProjectRegex(project) {
  var _a;
  if (uriCache.has(project))
    return uriCache.get(project);
  const plugin = getGlobalContext();
  if (!plugin.settings.project_urls_enabled)
    return void 0;
  const result = (_a = plugin.settings.project_regex_url_entries.find((entry) => new RegExp(entry.regexString).exec(project) !== null)) == null ? void 0 : _a.uri;
  if (result !== void 0)
    uriCache.set(project, result);
  return result;
}
var context = void 0;
function setGlobalContext(plugin) {
  context = {
    plugin,
    app: plugin.app
  };
}
function getGlobalContext() {
  return context.plugin;
}

// src/task-handler.ts
var asyncExec = (0, import_util.promisify)(import_child_process.exec);
var TaskHandler = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.reportColumnCache = /* @__PURE__ */ new Map();
    this.execTW = (args) => {
      let command = this.plugin.settings.tw_bin;
      if (Array.isArray(args))
        command += " " + args.map((s) => `"${s}"`).join(" ");
      else
        command += " " + args;
      this.plugin.logger.debug_log("Executing: \n", command);
      return ResultAsync.fromPromise(asyncExec(command).then((v) => v.stdout).then((r) => {
        this.plugin.logger.debug_log("Result: \n", r);
        return r;
      }), (e) => e instanceof Error ? e : new Error(String(e)));
    };
    this.fetchReportColumns = async (clean_report) => {
      if (this.plugin.settings.cache_columns && this.reportColumnCache.has(clean_report)) {
        return ok(this.reportColumnCache.get(clean_report));
      }
      const label_commands = ["_get", `rc.report.${clean_report}.labels`];
      const column_commands = ["_get", `rc.report.${clean_report}.columns`];
      const [labels, columns] = await Promise.all(
        [
          this.execTW(label_commands).then((r) => r.map((s) => s.trim().split(","))),
          this.execTW(column_commands).then((r) => r.map((s) => s.trim().split(",")))
        ]
      );
      if (labels.isErr()) {
        return err(labels.error);
      }
      if (columns.isErr()) {
        return err(columns.error);
      }
      const cols = columns.value.filter((p) => p.trim() !== "").map((col, i) => ({ label: labels.value[i], type: col }));
      if (this.plugin.settings.cache_columns) {
        this.reportColumnCache.set(clean_report, cols);
      }
      return ok(cols);
    };
    this.fetchReportTasks = async (clean_report, clean_command) => {
      const cleanReportNoQuotes = clean_report.slice(1, clean_report.length - 1);
      const colRes = await this.fetchReportColumns(cleanReportNoQuotes);
      if (colRes.isErr()) {
        return err(colRes.error);
      }
      const col = colRes.value;
      if (col.length === 0)
        return ok({ columns: [], tasks: [], printedColumns: [] });
      const colOverride = `rc.report.${cleanReportNoQuotes}.columns:${["uuid.long", "status.short", ...col.map((c) => c.type)].join(",")}`;
      const labOverride = `rc.report.${cleanReportNoQuotes}.labels:${["_tw_uuid", "_tw_status", ...col.map((c) => c.label)].join(",")}`;
      const verbosityOverride = `rc.verbose:label`;
      const colorOverride = `rc.color:0`;
      const widthOverride = `rc.defaultwidth:0`;
      const heightOverride = `rc.defaultheight:0`;
      const rowPaddingOverride = `rc.row.padding:0`;
      const columnPaddingOverride = `rc.column.padding:1`;
      const hyphenateOverride = `rc.hyphenate:0`;
      const fullcommand = `${clean_report} ${clean_command ? clean_command + " " : ""}` + [colOverride, labOverride, verbosityOverride, colorOverride, widthOverride, heightOverride, rowPaddingOverride, columnPaddingOverride, hyphenateOverride].map((s) => `"${s}"`).join(" ");
      const twRes = await this.execTW(fullcommand);
      if (twRes.isErr()) {
        return ok({ columns: col, tasks: [], printedColumns: [] });
      }
      const tw = twRes.value;
      const [labels, headerLine, ...taskLines] = tw.split("\n");
      const ocurrences = linearSearchOcurrence(" ", headerLine);
      const separatedLabels = sliceUsingSeparatorIndexes(labels, ocurrences).slice(2).map((l) => l.trim());
      const printedColumns = separatedLabels.map((l) => ({
        label: l,
        type: col.find((c) => c.label === l).type
      }));
      const taskList = [];
      for (let i = 0; i < taskLines.length; i++) {
        const taskLine = taskLines[i];
        const [rawUuid, rawStatus, ...rawData] = sliceUsingSeparatorIndexes(taskLine, ocurrences);
        const uuid = rawUuid.trim();
        if (uuid === "") {
          const prevTask = taskList[taskList.length - 1];
          rawData.forEach((v, i2, rawData2) => {
            const indData = rawData2[i2].trim();
            if (indData === "")
              return;
            prevTask.data[i2] += `
	${indData}`;
          });
          continue;
        }
        taskList.push({
          uuid,
          status: rawStatus.trim(),
          data: rawData.map((d) => d.trim())
        });
      }
      return ok({
        tasks: taskList,
        columns: col,
        printedColumns
      });
    };
    this.setTaskStatus = async (uuid, status) => {
      return this.execTW([uuid, "modify", `status:${status}`]).map((t) => {
      });
    };
    this.handleEvents = async (event) => {
      if (event === "pending-refresh" /* REFRESH */) {
        this.cachedTags = void 0;
        this.cachedProjects = void 0;
        this.cachedTaskTags.clear();
      }
    };
    // Helper functions
    this.cachedTags = void 0;
    this.cachedProjects = void 0;
    this.cachedTaskTags = /* @__PURE__ */ new Map();
    this.plugin.emitter.on("interval-fetch" /* INTERVAL */, () => this.handleEvents("interval-fetch" /* INTERVAL */));
    this.plugin.emitter.on("pending-refresh" /* REFRESH */, () => this.handleEvents("pending-refresh" /* REFRESH */));
  }
  clearColumnCache() {
    const cleared = this.reportColumnCache.size;
    this.reportColumnCache.clear();
    return cleared;
  }
  async getTasks(clean_report, clean_command) {
    const timestamp = Date.now();
    const result = await this.fetchReportTasks(clean_report, clean_command);
    if (result.isErr()) {
      this.plugin.logger.error_log(result.error);
      throw err(result.error);
    }
    return { report: result.value, timestamp };
  }
  createTask(command) {
    return this.execTW(`add ${command}`).map((v) => this.parseCreationModificationOutput(v)).andThen((v) => {
      if (v.length === 0)
        return err(new Error("No task created"));
      if (v.length > 1)
        throw err(new Error("Assertion failed: multiple tasks created"));
      this.plugin.emitter.emit("pending-refresh" /* REFRESH */);
      return ok(v[0]);
    }).andThen((v) => this.getUuidOfTask(v));
  }
  async getTags(uuid) {
    return this.execTW(`_tags${uuid ? " " + uuid : ""}`).map((v) => v.trim().split("\n").map((s) => s.trim()));
  }
  async getProjects() {
    return this.execTW(`_projects`).map((v) => v.trim().split("\n").map((s) => s.trim()));
  }
  async removeTag(uuid, tag) {
    const result = await this.execTW(`${uuid} modify -${tag}`);
    if (result.isErr())
      return result;
    this.plugin.emitter.emit("pending-refresh" /* REFRESH */);
    return ok(null);
  }
  async startTask(uuid) {
    const result = await this.execTW(`start ${uuid}`);
    if (result.isErr())
      return result;
    this.plugin.emitter.emit("pending-refresh" /* REFRESH */);
    return ok(null);
  }
  async stopTask(uuid) {
    const result = await this.execTW(`stop ${uuid}`);
    if (result.isErr())
      return result;
    this.plugin.emitter.emit("pending-refresh" /* REFRESH */);
    return ok(null);
  }
  async modifyTask(uuid, command) {
    const result = await this.execTW(`${uuid} modify ${command}`);
    if (result.isErr())
      return result;
    this.plugin.emitter.emit("pending-refresh" /* REFRESH */);
    return ok(null);
  }
  async deleteTask(uuid) {
    const result = await this.setTaskStatus(uuid, "deleted");
    if (result.isErr())
      return result;
    this.plugin.emitter.emit("pending-refresh" /* REFRESH */);
    return ok(null);
  }
  async completeTask(uuid) {
    const result = await this.execTW([uuid, "done"]);
    if (result.isErr())
      return result;
    this.plugin.emitter.emit("pending-refresh" /* REFRESH */);
    return ok(null);
  }
  async undoTask(uuid) {
    this.setTaskStatus(uuid, "pending");
    this.plugin.emitter.emit("pending-refresh" /* REFRESH */);
    return ok(null);
  }
  getUuidOfTask(id) {
    return this.execTW(["_get", `${id}.uuid`]).map((v) => v.trim());
  }
  parseCreationModificationOutput(output) {
    const lines = output.trim().split(/\n\r?/);
    return lines.map((l) => {
      var _a, _b;
      return (_b = (_a = /task (?<id>[0-9]+)/.exec(lines[0])) == null ? void 0 : _a.groups) == null ? void 0 : _b.id;
    }).filter((v) => v !== void 0 && v !== null);
  }
  async undo() {
    const result = await this.execTW(["rc.confirmation:0", "undo"]);
    if (result.isErr())
      return new import_obsidian.Notice("Error trying to undo last action");
    this.plugin.emitter.emit("pending-refresh" /* REFRESH */);
    new import_obsidian.Notice("Last action undone");
  }
  getTaskDetails(uuid, width) {
    if (!width)
      return this.execTW(["information", uuid]);
    else
      return this.execTW([`rc.defaultwidth:${width}`, "information", uuid]);
  }
  async getTagSuggestions() {
    if (this.cachedTags === void 0) {
      const res = await this.getTags();
      if (res.isErr()) {
        new import_obsidian.Notice(`Error getting tags: ${res.error}`);
        return [];
      }
      this.cachedTags = res.value;
    }
    return this.cachedTags;
  }
  async getProjectSuggestions() {
    if (this.cachedProjects === void 0) {
      const res2 = await this.getProjects();
      if (res2.isErr()) {
        new import_obsidian.Notice(`Error getting projects: ${res2.error}`);
        return [];
      }
      this.cachedProjects = res2.value;
    }
    const res = await this.getProjects();
    if (res.isErr()) {
      new import_obsidian.Notice(`Error getting projects: ${res.error}`);
      return [];
    }
    return res.value;
  }
  async getTaskTagsSuggestions(uuid) {
    if (!this.cachedTaskTags.has(uuid)) {
      const res = await this.getTags(uuid);
      if (res.isErr()) {
        new import_obsidian.Notice(`Error getting tags for task ${shortUuid(uuid)}: ${res.error}`);
        return [];
      }
      this.cachedTaskTags.set(uuid, res.value);
    }
    return this.cachedTaskTags.get(uuid);
  }
};
function linearSearchOcurrence(search, array) {
  const indices = [];
  for (let i = 0; i < array.length; i++) {
    if (array[i] === search)
      indices.push(i);
  }
  indices.push(array.length);
  return indices;
}
function sliceUsingSeparatorIndexes(input, indexes) {
  const result = [];
  let prevOcurrence = 0;
  for (let i = 0; i < indexes.length; i++) {
    result.push(input.slice(prevOcurrence, indexes[i]));
    prevOcurrence = indexes[i];
  }
  return result;
}

// src/ui/TaskList.svelte
var import_obsidian7 = require("obsidian");

// src/modals.ts
var import_obsidian4 = require("obsidian");

// src/ui/TaskCreate.svelte
var import_obsidian2 = require("obsidian");

// src/ui/components/SuggestionTextArea.svelte
var import_crypto = require("crypto");
function add_css(target) {
  append_styles(target, "svelte-lz2iow", ".suggestions-container.svelte-lz2iow{position:fixed;width:200px;overflow-y:auto;background:var(--background-secondary-alt);border:1px solid var(--background-modifier-border);border-radius:4px;box-shadow:0 2px 4px rgba(0, 0, 0, 0.1);z-index:9999}.suggestion.svelte-lz2iow{display:block;width:100%;font-size:0.8em;padding:0px;padding-left:10px;border:none;background:none;text-align:left;cursor:pointer}.accent-1.svelte-lz2iow{color:var(--color-red);background-color:rgba(var(--color-red-rgb), 0.01)}.accent-2.svelte-lz2iow{color:var(--color-orange);background-color:rgba(var(--color-orange-rgb), 0.01)}.accent-3.svelte-lz2iow{color:var(--color-yellow);background-color:rgba(var(--color-yellow-rgb), 0.01)}.accent-4.svelte-lz2iow{color:var(--color-green);background-color:rgba(var(--color-green-rgb), 0.01)}.accent-5.svelte-lz2iow{color:var(--color-cyan);background-color:rgba(var(--color-cyan-rgb), 0.01)}.accent-6.svelte-lz2iow{color:var(--color-blue);background-color:rgba(var(--color-blue-rgb), 0.01)}.suggestion.svelte-lz2iow:hover{background-color:var(--background-primary);color:var(--text-accent)}.command-input.svelte-lz2iow{width:100%;height:1.9em;resize:none;overflow-y:hidden;box-sizing:border-box}.suggestion.selected.svelte-lz2iow{background-color:var(--background-primary);color:var(--text-accent)}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[29] = list[i];
  child_ctx[31] = i;
  return child_ctx;
}
function create_if_block(ctx) {
  let div;
  let recalculateSuggestionBox_action;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*suggestions*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "suggestions-container svelte-lz2iow");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      ctx[28](div);
      if (!mounted) {
        dispose = action_destroyer(recalculateSuggestionBox_action = /*recalculateSuggestionBox*/
        ctx[14].call(null, div));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*textToId6, suggestions, selectedIndex*/
      8264) {
        each_value = ensure_array_like(
          /*suggestions*/
          ctx2[3]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
      ctx[28](null);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block(ctx) {
  let span;
  let t0_value = (
    /*suggestion*/
    ctx[29] + ""
  );
  let t0;
  let t1;
  let span_class_value;
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      attr(span, "class", span_class_value = `suggestion accent-${/*textToId6*/
      ctx[13](
        /*suggestion*/
        ctx[29]
      ) + 1} svelte-lz2iow`);
      toggle_class(
        span,
        "selected",
        /*i*/
        ctx[31] === /*selectedIndex*/
        ctx[6]
      );
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*suggestions*/
      8 && t0_value !== (t0_value = /*suggestion*/
      ctx2[29] + ""))
        set_data(t0, t0_value);
      if (dirty[0] & /*suggestions*/
      8 && span_class_value !== (span_class_value = `suggestion accent-${/*textToId6*/
      ctx2[13](
        /*suggestion*/
        ctx2[29]
      ) + 1} svelte-lz2iow`)) {
        attr(span, "class", span_class_value);
      }
      if (dirty[0] & /*suggestions, selectedIndex*/
      72) {
        toggle_class(
          span,
          "selected",
          /*i*/
          ctx2[31] === /*selectedIndex*/
          ctx2[6]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment(ctx) {
  let div;
  let textarea;
  let _autofocus_action;
  let t;
  let mounted;
  let dispose;
  let textarea_levels = [
    { class: "command-input" },
    { tabindex: "0" },
    { placeholder: (
      /*placeholder*/
      ctx[2]
    ) },
    { id: "create-command" },
    /*$$restProps*/
    ctx[19]
  ];
  let textarea_data = {};
  for (let i = 0; i < textarea_levels.length; i += 1) {
    textarea_data = assign(textarea_data, textarea_levels[i]);
  }
  let if_block = (
    /*suggestions*/
    ctx[3].length > 0 && !/*suggestionEscaped*/
    ctx[7] && create_if_block(ctx)
  );
  return {
    c() {
      div = element("div");
      textarea = element("textarea");
      t = space();
      if (if_block)
        if_block.c();
      set_attributes(textarea, textarea_data);
      toggle_class(textarea, "svelte-lz2iow", true);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, textarea);
      if (textarea.autofocus)
        textarea.focus();
      ctx[23](textarea);
      set_input_value(
        textarea,
        /*value*/
        ctx[0]
      );
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      if (!mounted) {
        dispose = [
          action_destroyer(_autofocus_action = /*_autofocus*/
          ctx[12].call(null, textarea)),
          listen(
            textarea,
            "keyup",
            /*keyup_handler_1*/
            ctx[24]
          ),
          listen(
            textarea,
            "keyup",
            /*keyup_handler*/
            ctx[21]
          ),
          listen(
            textarea,
            "keydown",
            /*keydown_handler_1*/
            ctx[25]
          ),
          listen(
            textarea,
            "keydown",
            /*keydown_handler*/
            ctx[22]
          ),
          listen(
            textarea,
            "input",
            /*textarea_input_handler*/
            ctx[26]
          ),
          listen(
            textarea,
            "input",
            /*input_handler*/
            ctx[27]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [
        { class: "command-input" },
        { tabindex: "0" },
        dirty[0] & /*placeholder*/
        4 && { placeholder: (
          /*placeholder*/
          ctx2[2]
        ) },
        { id: "create-command" },
        dirty[0] & /*$$restProps*/
        524288 && /*$$restProps*/
        ctx2[19]
      ]));
      if (dirty[0] & /*value*/
      1) {
        set_input_value(
          textarea,
          /*value*/
          ctx2[0]
        );
      }
      toggle_class(textarea, "svelte-lz2iow", true);
      if (
        /*suggestions*/
        ctx2[3].length > 0 && !/*suggestionEscaped*/
        ctx2[7]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      ctx[23](null);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function getSuggestions(incoming, all) {
  return all.map((tag) => ({
    tag,
    distance: levenshtein(tag, incoming)
  })).sort((a, b) => a.distance - b.distance).map(({ tag }) => tag).slice(0, 10);
}
function levenshtein(a, b) {
  const matrix = Array.from({ length: a.length + 1 }, () => Array(b.length + 1).fill(0));
  for (let i = 0; i <= a.length; i++) {
    matrix[i][0] = i;
  }
  for (let j = 0; j <= b.length; j++) {
    matrix[0][j] = j;
  }
  for (let i = 1; i <= a.length; i++) {
    for (let j = 1; j <= b.length; j++) {
      if (a[i - 1] === b[j - 1]) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(matrix[i - 1][j] + 1, matrix[i][j - 1] + 1, matrix[i - 1][j - 1] + 1);
      }
    }
  }
  return matrix[a.length][b.length];
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = ["patterns", "value", "autofocus", "placeholder"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  const dispatch = createEventDispatcher();
  let suggestions = [];
  let suggestionBox;
  let suggestionBoxAdjustmentPending = false;
  let selectedIndex = -1;
  let suggestionEscaped = false;
  const plugin = getGlobalContext();
  let { patterns } = $$props;
  let { value } = $$props;
  let { autofocus = false } = $$props;
  let { placeholder = "" } = $$props;
  function _autofocus(node) {
    if (autofocus)
      node.focus();
  }
  let inputElement;
  let inputAdjustmentPending = false;
  onMount(() => {
    $$invalidate(8, inputElement.value = value, inputElement);
    recalculateSuggestionBox();
  });
  function textToId6(text2) {
    return (0, import_crypto.createHash)("sha1").update(text2).digest().readUint8(0) % 6;
  }
  function recalculateSuggestionBox(node) {
    if (suggestions.length === 0)
      return;
    let targetNode = node !== null && node !== void 0 ? node : suggestionBox;
    if (!targetNode)
      return;
    const cursor = inputElement.selectionStart;
    const textBeforeCursor = inputElement.value.substring(0, cursor);
    const textAfterCursor = inputElement.value.substring(cursor);
    const mirror = document.createElement("div");
    const style = getComputedStyle(inputElement);
    for (let i = 0; i < style.length; i++) {
      mirror.style[style[i]] = style[style[i]];
    }
    const pre = document.createTextNode(textBeforeCursor);
    const post = document.createTextNode(textAfterCursor);
    const caretEl = document.createElement("span");
    caretEl.innerHTML = "&nbsp;";
    mirror.innerHTML = "";
    mirror.append(pre, caretEl, post);
    document.body.append(mirror);
    const rect = caretEl.getBoundingClientRect();
    const rect2 = mirror.getBoundingClientRect();
    const inputElementRect = inputElement.getBoundingClientRect();
    document.body.removeChild(mirror);
    const textInputLineHeight = inputElement.clientHeight;
    targetNode.style.top = `${inputElementRect.y + rect.y - rect2.y + textInputLineHeight}px`;
    targetNode.style.left = `${inputElementRect.x + rect.x - rect2.x}px`;
    $$invalidate(5, suggestionBoxAdjustmentPending = false);
  }
  function isSuggestionsValid() {
    return suggestions.length > 0 && selectedIndex !== -1 && !suggestionEscaped;
  }
  function isSuggestionsVisible() {
    return suggestions.length > 0 && !suggestionEscaped;
  }
  function applySuggestions() {
    if (selectedIndex !== -1 && suggestions.length > 0) {
      const cursor = inputElement.selectionStart;
      let start = cursor;
      let end = cursor;
      while (start > 0 && value[start - 1] !== " " && value[start - 1] !== "\n") {
        start--;
      }
      while (end < value.length && value[end] !== " " && value[end] !== "\n") {
        end++;
      }
      const word = value.substring(start, cursor);
      let endPos = end;
      const patternIndex = patterns.findIndex(({ pattern }) => word.startsWith(pattern));
      if (patternIndex !== -1) {
        $$invalidate(0, value = value.substring(0, start) + patterns[patternIndex].pattern + suggestions[selectedIndex] + value.substring(end));
        endPos = start + patterns[patternIndex].pattern.length + suggestions[selectedIndex].length;
      }
      $$invalidate(8, inputElement.value = value, inputElement);
      $$invalidate(8, inputElement.selectionStart = endPos, inputElement);
      $$invalidate(8, inputElement.selectionEnd = endPos, inputElement);
      inputElement.focus();
      $$invalidate(6, selectedIndex = -1);
      $$invalidate(7, suggestionEscaped = true);
    }
  }
  function adjustInputHeight() {
    $$invalidate(8, inputElement.style.height = "1.5em", inputElement);
    $$invalidate(8, inputElement.style.height = inputElement.scrollHeight + "px", inputElement);
    $$invalidate(9, inputAdjustmentPending = false);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler2(event) {
    bubble.call(this, $$self, event);
  }
  function textarea_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputElement = $$value;
      $$invalidate(8, inputElement);
    });
  }
  const keyup_handler_1 = (e) => {
    var _a;
    let preventEmittion = false;
    if (isSuggestionsValid()) {
      if (e.key === "Enter" && e.shiftKey === false) {
        (_a = plugin.logger) == null ? void 0 : _a.debug_log("Suggestion is valid and trying to enter!");
        applySuggestions();
        preventEmittion = true;
        e.preventDefault();
        e.stopImmediatePropagation();
        e.stopPropagation();
      }
    }
  };
  const keydown_handler_1 = (e) => {
    let preventEmittion = false;
    if (isSuggestionsVisible()) {
      if (e.key === "ArrowDown") {
        $$invalidate(6, selectedIndex++, selectedIndex);
        if (selectedIndex >= suggestions.length)
          $$invalidate(6, selectedIndex = selectedIndex % suggestions.length);
        preventEmittion = true;
        e.stopImmediatePropagation();
      }
      if (e.key === "ArrowUp") {
        $$invalidate(6, selectedIndex--, selectedIndex);
        if (selectedIndex < 0)
          $$invalidate(6, selectedIndex = suggestions.length - 1);
        preventEmittion = true;
        e.stopImmediatePropagation();
      }
      if (e.key === "Escape") {
        $$invalidate(7, suggestionEscaped = true);
        preventEmittion = true;
        e.stopImmediatePropagation();
        e.preventDefault();
      }
      ;
      if (isSuggestionsValid() && e.key === "Enter") {
        preventEmittion = true;
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
      }
    }
  };
  function textarea_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  const input_handler = (e) => {
    dispatch("input", e);
    if (!inputAdjustmentPending) {
      $$invalidate(9, inputAdjustmentPending = true);
      requestAnimationFrame(adjustInputHeight);
    }
    const currentCursor = inputElement.selectionStart;
    let cursor = currentCursor;
    const currentChar = value[currentCursor - 1];
    while (cursor > 0 && value[cursor - 1] !== " " && value[cursor - 1] !== "\n") {
      cursor--;
    }
    const currentWord = value.substring(cursor, currentCursor);
    const patternIndex = patterns.findIndex(({ pattern }) => currentWord.startsWith(pattern));
    if (patternIndex === -1) {
      $$invalidate(3, suggestions = []);
      $$invalidate(6, selectedIndex = -1);
      $$invalidate(7, suggestionEscaped = false);
    } else {
      patterns[patternIndex].getList(currentWord).then((incomingList) => {
        $$invalidate(3, suggestions = getSuggestions(currentWord, incomingList));
      });
    }
    if (!suggestionBoxAdjustmentPending && suggestions.length > 0 && !suggestionEscaped) {
      $$invalidate(5, suggestionBoxAdjustmentPending = true);
      requestAnimationFrame(() => recalculateSuggestionBox());
    }
  };
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      suggestionBox = $$value;
      $$invalidate(4, suggestionBox);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(19, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("patterns" in $$new_props)
      $$invalidate(1, patterns = $$new_props.patterns);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("autofocus" in $$new_props)
      $$invalidate(20, autofocus = $$new_props.autofocus);
    if ("placeholder" in $$new_props)
      $$invalidate(2, placeholder = $$new_props.placeholder);
  };
  return [
    value,
    patterns,
    placeholder,
    suggestions,
    suggestionBox,
    suggestionBoxAdjustmentPending,
    selectedIndex,
    suggestionEscaped,
    inputElement,
    inputAdjustmentPending,
    dispatch,
    plugin,
    _autofocus,
    textToId6,
    recalculateSuggestionBox,
    isSuggestionsValid,
    isSuggestionsVisible,
    applySuggestions,
    adjustInputHeight,
    $$restProps,
    autofocus,
    keyup_handler,
    keydown_handler2,
    textarea_binding,
    keyup_handler_1,
    keydown_handler_1,
    textarea_input_handler,
    input_handler,
    div_binding
  ];
}
var SuggestionTextArea = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        patterns: 1,
        value: 0,
        autofocus: 20,
        placeholder: 2
      },
      add_css,
      [-1, -1]
    );
  }
};
var SuggestionTextArea_default = SuggestionTextArea;

// src/ui/TaskCreate.svelte
function add_css2(target) {
  append_styles(target, "svelte-12ouvyn", ".actions-container.svelte-12ouvyn{display:flex}.action-button.svelte-12ouvyn{margin-left:5px;margin-right:5px}.delete-button.svelte-12ouvyn{margin-left:5px;margin-right:5px;color:var(--text-error)}.command.svelte-12ouvyn{font-family:monospace;font-size:0.8em;color:var(--text-muted);word-break:break-all;white-space:normal}.uuid-text.svelte-12ouvyn{font-size:0.8em;color:var(--text-muted);background-color:var(--background-secondary-alt)}.task-selected.svelte-12ouvyn{color:var(--text-accent)}.push-right.svelte-12ouvyn{margin-left:auto}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[28] = list[i].uuid;
  child_ctx[29] = list[i].description;
  child_ctx[31] = i;
  return child_ctx;
}
function create_each_block2(ctx) {
  var _a, _b, _c, _d;
  let div;
  let button0;
  let html_tag;
  let raw0_value = ((_a = (0, import_obsidian2.getIcon)(
    /*uuid*/
    ctx[28] === /*lastCreatedUuid*/
    ctx[3] ? "square-mouse-pointer" : "square-dashed-mouse-pointer"
  )) == null ? void 0 : _a.outerHTML) + "";
  let t0;
  let pre0;
  let t2;
  let t3_value = limitString(
    /*description*/
    (_b = ctx[29]) != null ? _b : ""
  ) + "";
  let t3;
  let t4;
  let button1;
  let t5_value = shortUuid(
    /*uuid*/
    ctx[28]
  ) + "";
  let t5;
  let t6;
  let pre1;
  let t8;
  let html_tag_1;
  let raw1_value = ((_c = (0, import_obsidian2.getIcon)("copy")) == null ? void 0 : _c.outerHTML) + "";
  let t9;
  let button2;
  let raw2_value = ((_d = (0, import_obsidian2.getIcon)("trash")) == null ? void 0 : _d.outerHTML) + "";
  let t10;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[22](
        /*uuid*/
        ctx[28]
      )
    );
  }
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[23](
        /*uuid*/
        ctx[28]
      )
    );
  }
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[24](
        /*uuid*/
        ctx[28]
      )
    );
  }
  return {
    c() {
      div = element("div");
      button0 = element("button");
      html_tag = new HtmlTag(false);
      t0 = space();
      pre0 = element("pre");
      pre0.textContent = " ";
      t2 = space();
      t3 = text(t3_value);
      t4 = space();
      button1 = element("button");
      t5 = text(t5_value);
      t6 = space();
      pre1 = element("pre");
      pre1.textContent = " ";
      t8 = space();
      html_tag_1 = new HtmlTag(false);
      t9 = space();
      button2 = element("button");
      t10 = space();
      html_tag.a = t0;
      attr(button0, "class", "uuid-text svelte-12ouvyn");
      toggle_class(
        button0,
        "task-selected",
        /*uuid*/
        ctx[28] === /*lastCreatedUuid*/
        ctx[3]
      );
      html_tag_1.a = null;
      attr(button1, "class", "uuid-text push-right svelte-12ouvyn");
      attr(button2, "class", "delete-button svelte-12ouvyn");
      set_style(div, "display", "flex");
      set_style(div, "margin-top", "5px");
      set_style(div, "margin-bottom", "5px");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button0);
      html_tag.m(raw0_value, button0);
      append(button0, t0);
      append(button0, pre0);
      append(button0, t2);
      append(button0, t3);
      append(div, t4);
      append(div, button1);
      append(button1, t5);
      append(button1, t6);
      append(button1, pre1);
      append(button1, t8);
      html_tag_1.m(raw1_value, button1);
      append(div, t9);
      append(div, button2);
      button2.innerHTML = raw2_value;
      append(div, t10);
      if (!mounted) {
        dispose = [
          listen(button0, "click", click_handler),
          listen(button1, "click", click_handler_1),
          listen(button2, "click", click_handler_2)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      var _a2, _b2;
      ctx = new_ctx;
      if (dirty[0] & /*createdUuids, lastCreatedUuid*/
      24 && raw0_value !== (raw0_value = ((_a2 = (0, import_obsidian2.getIcon)(
        /*uuid*/
        ctx[28] === /*lastCreatedUuid*/
        ctx[3] ? "square-mouse-pointer" : "square-dashed-mouse-pointer"
      )) == null ? void 0 : _a2.outerHTML) + ""))
        html_tag.p(raw0_value);
      if (dirty[0] & /*createdUuids*/
      16 && t3_value !== (t3_value = limitString(
        /*description*/
        (_b2 = ctx[29]) != null ? _b2 : ""
      ) + ""))
        set_data(t3, t3_value);
      if (dirty[0] & /*createdUuids, lastCreatedUuid*/
      24) {
        toggle_class(
          button0,
          "task-selected",
          /*uuid*/
          ctx[28] === /*lastCreatedUuid*/
          ctx[3]
        );
      }
      if (dirty[0] & /*createdUuids*/
      16 && t5_value !== (t5_value = shortUuid(
        /*uuid*/
        ctx[28]
      ) + ""))
        set_data(t5, t5_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment2(ctx) {
  let div3;
  let suggestiontextarea;
  let updating_value;
  let t0;
  let p;
  let t1;
  let t2;
  let div0;
  let t3;
  let div2;
  let div1;
  let button0;
  let t4;
  let button0_disabled_value;
  let t5;
  let button1;
  let t6;
  let button1_disabled_value;
  let current;
  let mounted;
  let dispose;
  function suggestiontextarea_value_binding(value) {
    ctx[20](value);
  }
  let suggestiontextarea_props = {
    patterns: (
      /*patterns*/
      ctx[14]
    ),
    autofocus: true,
    placeholder: "My new task priority:L"
  };
  if (
    /*input*/
    ctx[0] !== void 0
  ) {
    suggestiontextarea_props.value = /*input*/
    ctx[0];
  }
  suggestiontextarea = new SuggestionTextArea_default({ props: suggestiontextarea_props });
  binding_callbacks.push(() => bind(suggestiontextarea, "value", suggestiontextarea_value_binding));
  suggestiontextarea.$on(
    "keyup",
    /*handleKeyUp*/
    ctx[13]
  );
  suggestiontextarea.$on("keydown", handleKeyDown);
  suggestiontextarea.$on(
    "input",
    /*input_handler*/
    ctx[21]
  );
  let each_value = ensure_array_like(
    /*createdUuids*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  return {
    c() {
      div3 = element("div");
      create_component(suggestiontextarea.$$.fragment);
      t0 = space();
      p = element("p");
      t1 = text(
        /*displayedCommand*/
        ctx[1]
      );
      t2 = space();
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t3 = space();
      div2 = element("div");
      div1 = element("div");
      button0 = element("button");
      t4 = text("Modify");
      t5 = space();
      button1 = element("button");
      t6 = text("Create");
      attr(p, "class", "command svelte-12ouvyn");
      attr(p, "id", "command-to-run");
      set_style(div0, "width", "100%");
      set_style(div0, "margin-bottom", "15px");
      attr(button0, "class", "action-button svelte-12ouvyn");
      button0.disabled = button0_disabled_value = !/*readyToCreate*/
      ctx[5] || !/*lastCreatedUuid*/
      ctx[3];
      attr(button1, "class", "action-button svelte-12ouvyn");
      button1.disabled = button1_disabled_value = !/*readyToCreate*/
      ctx[5];
      set_style(div1, "display", "flex");
      set_style(div1, "margin-left", "auto");
      attr(div2, "class", "actions-container svelte-12ouvyn");
      attr(div3, "role", "textbox");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      mount_component(suggestiontextarea, div3, null);
      append(div3, t0);
      append(div3, p);
      append(p, t1);
      append(div3, t2);
      append(div3, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append(div3, t3);
      append(div3, div2);
      append(div2, div1);
      append(div1, button0);
      append(button0, t4);
      append(div1, t5);
      append(div1, button1);
      append(button1, t6);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler_3*/
            ctx[25]
          ),
          listen(
            button1,
            "click",
            /*click_handler_4*/
            ctx[26]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const suggestiontextarea_changes = {};
      if (!updating_value && dirty[0] & /*input*/
      1) {
        updating_value = true;
        suggestiontextarea_changes.value = /*input*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      suggestiontextarea.$set(suggestiontextarea_changes);
      if (!current || dirty[0] & /*displayedCommand*/
      2)
        set_data(
          t1,
          /*displayedCommand*/
          ctx2[1]
        );
      if (dirty[0] & /*deleteTask, createdUuids, copyToClipboard, lastCreatedUuid, selectTask*/
      7192) {
        each_value = ensure_array_like(
          /*createdUuids*/
          ctx2[4]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div0, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current || dirty[0] & /*readyToCreate, lastCreatedUuid*/
      40 && button0_disabled_value !== (button0_disabled_value = !/*readyToCreate*/
      ctx2[5] || !/*lastCreatedUuid*/
      ctx2[3])) {
        button0.disabled = button0_disabled_value;
      }
      if (!current || dirty[0] & /*readyToCreate*/
      32 && button1_disabled_value !== (button1_disabled_value = !/*readyToCreate*/
      ctx2[5])) {
        button1.disabled = button1_disabled_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(suggestiontextarea.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(suggestiontextarea.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_component(suggestiontextarea);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function handleKeyDown(e) {
  const te = e;
  if (te.key === "Enter" && te.shiftKey === false)
    e.preventDefault();
}
function instance2($$self, $$props, $$invalidate) {
  let { plugin } = $$props;
  let { titleElement } = $$props;
  let { template } = $$props;
  let { close } = $$props;
  let state = "ok";
  let input;
  let displayedCommand = "task add";
  let displayedCommandPending = false;
  let lastCreatedUuid = void 0;
  let createdUuids = [];
  let readyToCreate = false;
  function getSanitizedInput(disableTemplate) {
    return `${sanitize(input || "")}${template && !disableTemplate ? " " + sanitize(template) : ""}`;
  }
  function clearInput() {
    $$invalidate(0, input = "");
  }
  async function createTask(cmd) {
    $$invalidate(19, state = "loading");
    await plugin.handler.createTask(cmd).match(
      (v) => {
        new import_obsidian2.Notice(`Task ${shortUuid(v)} created.`);
        $$invalidate(3, lastCreatedUuid = v);
        createdUuids.push({ uuid: v, description: cmd });
      },
      (err2) => {
        new import_obsidian2.Notice(`Error creating task: ${err2}`);
        $$invalidate(19, state = "error");
      }
    );
    $$invalidate(19, state = "ok");
  }
  async function modifyTask(cmd) {
    $$invalidate(19, state = "loading");
    if (!lastCreatedUuid) {
      new import_obsidian2.Notice("No UUID created yet.");
      $$invalidate(19, state = "error");
      return;
    }
    (await plugin.handler.modifyTask(lastCreatedUuid, cmd)).match(
      (_) => {
        new import_obsidian2.Notice(`Task ${shortUuid(lastCreatedUuid)} modified.`);
        $$invalidate(4, createdUuids[createdUuids.findIndex((e) => e.uuid === lastCreatedUuid)]["description"] = cmd, createdUuids);
      },
      (err2) => {
        new import_obsidian2.Notice(`Error modifying task: ${err2}`);
        $$invalidate(19, state = "error");
      }
    );
    $$invalidate(19, state = "ok");
  }
  async function deleteTask(uuid) {
    $$invalidate(19, state = "loading");
    (await plugin.handler.deleteTask(uuid)).match(
      (_) => {
        new import_obsidian2.Notice(`Task ${shortUuid(uuid)} deleted.`);
        $$invalidate(4, createdUuids = createdUuids.filter((e) => e.uuid !== uuid));
        if (lastCreatedUuid === uuid)
          $$invalidate(3, lastCreatedUuid = void 0);
      },
      (err2) => {
        new import_obsidian2.Notice(`Error deleting task: ${err2}`);
        $$invalidate(19, state = "error");
      }
    );
    $$invalidate(19, state = "ok");
  }
  async function selectTask(uuid) {
    $$invalidate(3, lastCreatedUuid = uuid);
  }
  onMount(() => {
    titleElement.setText("Create New Tasks");
    $$invalidate(0, input = "");
    $$invalidate(1, displayedCommand = `task add ${getSanitizedInput()}`);
  });
  function closeModal() {
    close();
  }
  async function copyToClipboard(c) {
    await navigator.clipboard.writeText(c);
    new import_obsidian2.Notice("Copied to clipboard");
  }
  function handleKeyUp(e) {
    const te = e;
    if (te.key === "Enter" && readyToCreate && te.shiftKey === false) {
      if (lastCreatedUuid !== void 0 && te.ctrlKey === true) {
        modifyTask(getSanitizedInput(true));
        e.preventDefault();
        e.stopPropagation();
        clearInput();
      } else {
        createTask(getSanitizedInput());
        e.preventDefault();
        e.stopPropagation();
        clearInput();
      }
    }
  }
  const patterns = [
    {
      pattern: "+",
      getList: async (_s) => plugin.handler.getTagSuggestions()
    },
    {
      pattern: "project:",
      getList: async (_s) => plugin.handler.getProjectSuggestions()
    }
  ];
  function suggestiontextarea_value_binding(value) {
    input = value;
    $$invalidate(0, input);
  }
  const input_handler = () => {
    if (!displayedCommandPending) {
      $$invalidate(2, displayedCommandPending = true);
      requestAnimationFrame(() => {
        $$invalidate(1, displayedCommand = `task add ${getSanitizedInput()}`);
        $$invalidate(2, displayedCommandPending = false);
      });
    }
  };
  const click_handler = (uuid) => {
    selectTask(uuid);
  };
  const click_handler_1 = (uuid) => {
    copyToClipboard(uuid);
  };
  const click_handler_2 = (uuid) => deleteTask(uuid);
  const click_handler_3 = () => {
    modifyTask(getSanitizedInput(false));
    clearInput();
  };
  const click_handler_4 = () => {
    createTask(getSanitizedInput());
    clearInput();
  };
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(15, plugin = $$props2.plugin);
    if ("titleElement" in $$props2)
      $$invalidate(16, titleElement = $$props2.titleElement);
    if ("template" in $$props2)
      $$invalidate(17, template = $$props2.template);
    if ("close" in $$props2)
      $$invalidate(18, close = $$props2.close);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*state, input*/
    524289) {
      $: {
        $$invalidate(5, readyToCreate = state !== "loading" && input !== void 0 && input !== "");
      }
    }
  };
  return [
    input,
    displayedCommand,
    displayedCommandPending,
    lastCreatedUuid,
    createdUuids,
    readyToCreate,
    getSanitizedInput,
    clearInput,
    createTask,
    modifyTask,
    deleteTask,
    selectTask,
    copyToClipboard,
    handleKeyUp,
    patterns,
    plugin,
    titleElement,
    template,
    close,
    state,
    suggestiontextarea_value_binding,
    input_handler,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4
  ];
}
var TaskCreate = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        plugin: 15,
        titleElement: 16,
        template: 17,
        close: 18
      },
      add_css2,
      [-1, -1]
    );
  }
};
var TaskCreate_default = TaskCreate;

// src/ui/TaskModify.svelte
var import_obsidian3 = require("obsidian");
function add_css3(target) {
  append_styles(target, "svelte-jo8985", ".actions-container.svelte-jo8985{display:flex}.action-button.svelte-jo8985{margin-left:5px;margin-right:5px}.action-button-error.svelte-jo8985{margin-left:5px;margin-right:5px;color:var(--text-error)}.details.svelte-jo8985{font-family:monospace;font-size:1em;line-height:0.9;width:100%;color:var(--text-muted);text-wrap:nowrap;overflow:hidden;user-select:text;-webkit-user-select:text;white-space:pre}.command.svelte-jo8985{font-family:monospace;font-size:0.8em;color:var(--text-muted)}.uuid-text.svelte-jo8985{font-size:0.8em;color:var(--text-muted);background-color:var(--background-secondary-alt)}");
}
function create_fragment3(ctx) {
  var _a, _b;
  let div4;
  let suggestiontextarea;
  let updating_value;
  let t0;
  let p0;
  let t1;
  let t2;
  let div0;
  let p1;
  let t3_value = (
    /*details*/
    (ctx[5] ? (
      /*details*/
      ctx[5]
    ) : "Fetching...") + ""
  );
  let t3;
  let t4;
  let div3;
  let div1;
  let button0;
  let raw0_value = ((_a = (0, import_obsidian3.getIcon)("trash")) == null ? void 0 : _a.outerHTML) + "";
  let button0_disabled_value;
  let t5;
  let div2;
  let button1;
  let t6_value = shortUuid(
    /*task*/
    ctx[0].uuid
  ) + "";
  let t6;
  let pre;
  let t8;
  let html_tag;
  let raw1_value = ((_b = (0, import_obsidian3.getIcon)("copy")) == null ? void 0 : _b.outerHTML) + "";
  let t9;
  let button2;
  let t10;
  let button2_disabled_value;
  let current;
  let mounted;
  let dispose;
  function suggestiontextarea_value_binding(value) {
    ctx[17](value);
  }
  let suggestiontextarea_props = {
    patterns: (
      /*patterns*/
      ctx[12]
    ),
    autofocus: true,
    placeholder: "due:tomorrow"
  };
  if (
    /*input*/
    ctx[2] !== void 0
  ) {
    suggestiontextarea_props.value = /*input*/
    ctx[2];
  }
  suggestiontextarea = new SuggestionTextArea_default({ props: suggestiontextarea_props });
  binding_callbacks.push(() => bind(suggestiontextarea, "value", suggestiontextarea_value_binding));
  suggestiontextarea.$on(
    "keyup",
    /*keyup_handler*/
    ctx[18]
  );
  suggestiontextarea.$on("keydown", keydown_handler);
  suggestiontextarea.$on(
    "input",
    /*input_handler*/
    ctx[19]
  );
  return {
    c() {
      div4 = element("div");
      create_component(suggestiontextarea.$$.fragment);
      t0 = space();
      p0 = element("p");
      t1 = text(
        /*displayedCommand*/
        ctx[3]
      );
      t2 = space();
      div0 = element("div");
      p1 = element("p");
      t3 = text(t3_value);
      t4 = space();
      div3 = element("div");
      div1 = element("div");
      button0 = element("button");
      t5 = space();
      div2 = element("div");
      button1 = element("button");
      t6 = text(t6_value);
      pre = element("pre");
      pre.textContent = " ";
      t8 = space();
      html_tag = new HtmlTag(false);
      t9 = space();
      button2 = element("button");
      t10 = text("Modify");
      attr(p0, "class", "command svelte-jo8985");
      attr(p0, "id", "command-to-run");
      attr(p1, "class", "details svelte-jo8985");
      attr(button0, "class", "action-button-error svelte-jo8985");
      button0.disabled = button0_disabled_value = /*state*/
      ctx[1] === "loading";
      set_style(div1, "display", "flex");
      html_tag.a = null;
      attr(button1, "class", "uuid-text action-button svelte-jo8985");
      attr(button2, "class", "action-button svelte-jo8985");
      button2.disabled = button2_disabled_value = !/*readyToModify*/
      ctx[7];
      set_style(div2, "display", "flex");
      set_style(div2, "margin-left", "auto");
      attr(div3, "class", "actions-container svelte-jo8985");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      mount_component(suggestiontextarea, div4, null);
      append(div4, t0);
      append(div4, p0);
      append(p0, t1);
      append(div4, t2);
      append(div4, div0);
      append(div0, p1);
      append(p1, t3);
      ctx[20](p1);
      append(div4, t4);
      append(div4, div3);
      append(div3, div1);
      append(div1, button0);
      button0.innerHTML = raw0_value;
      append(div3, t5);
      append(div3, div2);
      append(div2, button1);
      append(button1, t6);
      append(button1, pre);
      append(button1, t8);
      html_tag.m(raw1_value, button1);
      append(div2, t9);
      append(div2, button2);
      append(button2, t10);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*deleteTask*/
            ctx[11]
          ),
          listen(
            button1,
            "click",
            /*click_handler*/
            ctx[21]
          ),
          listen(
            button2,
            "click",
            /*click_handler_1*/
            ctx[22]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const suggestiontextarea_changes = {};
      if (!updating_value && dirty & /*input*/
      4) {
        updating_value = true;
        suggestiontextarea_changes.value = /*input*/
        ctx2[2];
        add_flush_callback(() => updating_value = false);
      }
      suggestiontextarea.$set(suggestiontextarea_changes);
      if (!current || dirty & /*displayedCommand*/
      8)
        set_data(
          t1,
          /*displayedCommand*/
          ctx2[3]
        );
      if ((!current || dirty & /*details*/
      32) && t3_value !== (t3_value = /*details*/
      (ctx2[5] ? (
        /*details*/
        ctx2[5]
      ) : "Fetching...") + ""))
        set_data(t3, t3_value);
      if (!current || dirty & /*state*/
      2 && button0_disabled_value !== (button0_disabled_value = /*state*/
      ctx2[1] === "loading")) {
        button0.disabled = button0_disabled_value;
      }
      if ((!current || dirty & /*task*/
      1) && t6_value !== (t6_value = shortUuid(
        /*task*/
        ctx2[0].uuid
      ) + ""))
        set_data(t6, t6_value);
      if (!current || dirty & /*readyToModify*/
      128 && button2_disabled_value !== (button2_disabled_value = !/*readyToModify*/
      ctx2[7])) {
        button2.disabled = button2_disabled_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(suggestiontextarea.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(suggestiontextarea.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      destroy_component(suggestiontextarea);
      ctx[20](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
var keydown_handler = (e) => {
  if (e.key === "Enter" && !e.shiftKey)
    e.preventDefault();
};
function instance3($$self, $$props, $$invalidate) {
  let { close } = $$props;
  let { plugin } = $$props;
  let { task } = $$props;
  let { titleElement } = $$props;
  let { inputValue } = $$props;
  let state = "ok";
  let input;
  let displayedCommand = `task modify ${shortUuid(task.uuid)}`;
  let displayedCommandPending = false;
  let details = void 0;
  let detailElement;
  let readyToModify;
  function getSanitizedInput() {
    return `${sanitize(input || "")}`;
  }
  function clearInput() {
    $$invalidate(2, input = "");
  }
  async function modifyTask(cmd) {
    $$invalidate(1, state = "loading");
    (await plugin.handler.modifyTask(task.uuid, cmd)).match(
      (_) => {
        $$invalidate(1, state = "ok");
        new import_obsidian3.Notice(`Task ${shortUuid(task.uuid)} modified.`);
      },
      (err2) => {
        $$invalidate(1, state = "error");
        new import_obsidian3.Notice(`Could not modify task ${shortUuid(task.uuid)}!: ${err2}`, 5e3);
      }
    );
    clearInput();
  }
  function calculateDetailCharacterWidth() {
    const container = detailElement;
    const measureChar = document.createElement("span");
    measureChar.style.fontFamily = "monospace";
    measureChar.style.fontSize = "1em";
    measureChar.style.visibility = "hidden";
    measureChar.textContent = "X";
    container.appendChild(measureChar);
    const charWidth = measureChar.getBoundingClientRect().width;
    const containerWidth = container.getBoundingClientRect().width;
    container.removeChild(measureChar);
    return Math.floor(containerWidth / charWidth);
  }
  async function fetchDetails() {
    const result = await plugin.handler.getTaskDetails(task.uuid, calculateDetailCharacterWidth());
    if (result.isOk()) {
      $$invalidate(5, details = result.value);
    }
  }
  onMount(() => {
    titleElement.setText(`Modify task ${task.taskName || shortUuid(task.uuid)}`);
    $$invalidate(2, input = inputValue || "");
    $$invalidate(3, displayedCommand = `task modify ${shortUuid(task.uuid)} ${getSanitizedInput()}`);
    fetchDetails();
    plugin.emitter.on("pending-refresh" /* REFRESH */, fetchDetails);
  });
  onDestroy(() => {
    plugin.emitter.off("pending-refresh" /* REFRESH */, fetchDetails);
  });
  async function copyToClipboard(c) {
    await navigator.clipboard.writeText(c);
    new import_obsidian3.Notice("Copied to clipboard");
  }
  async function deleteTask() {
    var _a;
    const result = await ((_a = plugin.handler) === null || _a === void 0 ? void 0 : _a.deleteTask(task.uuid));
    if (result === null || result === void 0 ? void 0 : result.isOk)
      close();
  }
  const patterns = [
    {
      pattern: "-",
      getList: async (_s) => plugin.handler.getTaskTagsSuggestions(task.uuid)
    },
    {
      pattern: "+",
      // TODO:
      getList: async (_s) => plugin.handler.getTagSuggestions()
    },
    {
      pattern: "project:",
      getList: async (_s) => plugin.handler.getProjectSuggestions()
    }
  ];
  function suggestiontextarea_value_binding(value) {
    input = value;
    $$invalidate(2, input);
  }
  const keyup_handler = (e) => {
    if (e.key === "Enter" && readyToModify && !e.shiftKey) {
      modifyTask(getSanitizedInput());
      e.preventDefault();
    }
  };
  const input_handler = () => {
    if (!displayedCommandPending) {
      $$invalidate(4, displayedCommandPending = true);
      requestAnimationFrame(() => {
        $$invalidate(3, displayedCommand = `task modify ${shortUuid(task.uuid)} ${getSanitizedInput()}`);
        $$invalidate(4, displayedCommandPending = false);
      });
    }
  };
  function p1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      detailElement = $$value;
      $$invalidate(6, detailElement);
    });
  }
  const click_handler = () => copyToClipboard(task.uuid);
  const click_handler_1 = () => modifyTask(getSanitizedInput());
  $$self.$$set = ($$props2) => {
    if ("close" in $$props2)
      $$invalidate(13, close = $$props2.close);
    if ("plugin" in $$props2)
      $$invalidate(14, plugin = $$props2.plugin);
    if ("task" in $$props2)
      $$invalidate(0, task = $$props2.task);
    if ("titleElement" in $$props2)
      $$invalidate(15, titleElement = $$props2.titleElement);
    if ("inputValue" in $$props2)
      $$invalidate(16, inputValue = $$props2.inputValue);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*state, input*/
    6) {
      $: {
        $$invalidate(7, readyToModify = state !== "loading" && input !== void 0 && input !== "");
      }
    }
  };
  return [
    task,
    state,
    input,
    displayedCommand,
    displayedCommandPending,
    details,
    detailElement,
    readyToModify,
    getSanitizedInput,
    modifyTask,
    copyToClipboard,
    deleteTask,
    patterns,
    close,
    plugin,
    titleElement,
    inputValue,
    suggestiontextarea_value_binding,
    keyup_handler,
    input_handler,
    p1_binding,
    click_handler,
    click_handler_1
  ];
}
var TaskModify = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance3,
      create_fragment3,
      safe_not_equal,
      {
        close: 13,
        plugin: 14,
        task: 0,
        titleElement: 15,
        inputValue: 16
      },
      add_css3
    );
  }
};
var TaskModify_default = TaskModify;

// src/modals.ts
var TWPModal = class extends import_obsidian4.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
};
var CreateTaskModal = class extends TWPModal {
  constructor(template) {
    const plugin = getGlobalContext();
    super(plugin.app, plugin);
    this.template = template;
  }
  onOpen() {
    const { titleEl, contentEl } = this;
    this.ctModal = new TaskCreate_default({
      target: contentEl,
      props: {
        close: () => this.close(),
        plugin: this.plugin,
        titleElement: titleEl,
        template: this.template
      }
    });
  }
  onClose() {
    var _a;
    (_a = this.ctModal) == null ? void 0 : _a.$destroy();
    const { contentEl } = this;
    contentEl.empty();
  }
};
var UpdateTaskModal = class extends TWPModal {
  constructor(task, options) {
    const plugin = getGlobalContext();
    super(plugin.app, plugin);
    this.task = task;
    this.inputValue = (options == null ? void 0 : options.value) || "";
  }
  onOpen() {
    const { titleEl, contentEl } = this;
    this.ctModal = new TaskModify_default({
      target: contentEl,
      props: {
        close: () => this.close(),
        plugin: this.plugin,
        task: this.task,
        inputValue: this.inputValue,
        titleElement: titleEl
      }
    });
  }
  onClose() {
    var _a;
    (_a = this.ctModal) == null ? void 0 : _a.$destroy();
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/ui/CustomActionMenu.ts
var import_obsidian5 = require("obsidian");
function runCommandOnTask(taskUuid, command, plugin) {
  plugin.handler.modifyTask(taskUuid, command).then(() => {
    new import_obsidian5.Notice(`Task ${taskUuid} modified.`);
    plugin.emitter.emit("pending-refresh" /* REFRESH */);
  }).catch(() => {
    new import_obsidian5.Notice(`Could not modify task ${taskUuid}!`, 5e3);
  });
}
function showActionMenu(taskUuid, event, plugin) {
  event.preventDefault();
  const menu = new import_obsidian5.Menu();
  for (const action of plugin.settings.right_click_context_menu_actions.values()) {
    menu.addItem(
      (item) => item.setTitle(action.ActionName).setIcon("documents").onClick(() => {
        runCommandOnTask(taskUuid, action.Action, plugin);
      })
    );
  }
  menu.showAtMouseEvent(event);
}

// src/ui/col/status.svelte
var import_obsidian6 = require("obsidian");
function add_css4(target) {
  append_styles(target, "svelte-ijdzoh", ".small-checkbox.svelte-ijdzoh{margin:0}.small-delete-button.svelte-ijdzoh{padding:2px;margin:0;overflow:hidden;flex-shrink:0;border-radius:var(--checkbox-radius);border:1px solid var(--checkbox-border-color);height:var(--checkbox-size);width:var(--checkbox-size)}.center-td.svelte-ijdzoh{text-align:center}");
}
function create_else_block_1(ctx) {
  var _a;
  let td;
  let button;
  let raw_value = ((_a = (0, import_obsidian6.getIcon)("cross")) == null ? void 0 : _a.outerHTML) + "";
  let mounted;
  let dispose;
  return {
    c() {
      td = element("td");
      button = element("button");
      button.disabled = /*disabled*/
      ctx[1];
      attr(button, "class", "small-delete-button svelte-ijdzoh");
      attr(td, "class", "center-td svelte-ijdzoh");
    },
    m(target, anchor) {
      insert(target, td, anchor);
      append(td, button);
      button.innerHTML = raw_value;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_2*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*disabled*/
      2) {
        button.disabled = /*disabled*/
        ctx2[1];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(td);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3(ctx) {
  var _a;
  let td;
  let button;
  let raw_value = ((_a = (0, import_obsidian6.getIcon)("undo")) == null ? void 0 : _a.outerHTML) + "";
  let mounted;
  let dispose;
  return {
    c() {
      td = element("td");
      button = element("button");
      button.disabled = /*disabled*/
      ctx[1];
      attr(button, "class", "small-delete-button svelte-ijdzoh");
      attr(td, "class", "center-td svelte-ijdzoh");
    },
    m(target, anchor) {
      insert(target, td, anchor);
      append(td, button);
      button.innerHTML = raw_value;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_1*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*disabled*/
      2) {
        button.disabled = /*disabled*/
        ctx2[1];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(td);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block2(ctx) {
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (
      /*status*/
      ctx2[0] === "D"
    )
      return create_if_block_1;
    if (
      /*status*/
      ctx2[0] === "R"
    )
      return create_if_block_2;
    return create_else_block;
  }
  let current_block_type = select_block_type_1(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_else_block(ctx) {
  let td;
  let input;
  let input_checked_value;
  let mounted;
  let dispose;
  return {
    c() {
      td = element("td");
      input = element("input");
      input.disabled = /*disabled*/
      ctx[1];
      attr(input, "class", "small-checkbox svelte-ijdzoh");
      attr(input, "type", "checkbox");
      input.checked = input_checked_value = /*status*/
      ctx[0] === "C";
      attr(td, "class", "center-td svelte-ijdzoh");
    },
    m(target, anchor) {
      insert(target, td, anchor);
      append(td, input);
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*change_handler*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*disabled*/
      2) {
        input.disabled = /*disabled*/
        ctx2[1];
      }
      if (dirty & /*status*/
      1 && input_checked_value !== (input_checked_value = /*status*/
      ctx2[0] === "C")) {
        input.checked = input_checked_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(td);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2(ctx) {
  let td;
  return {
    c() {
      td = element("td");
      td.innerHTML = ``;
      attr(td, "class", "center-td svelte-ijdzoh");
    },
    m(target, anchor) {
      insert(target, td, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(td);
      }
    }
  };
}
function create_if_block_1(ctx) {
  var _a;
  let td;
  let button;
  let raw_value = ((_a = (0, import_obsidian6.getIcon)("undo")) == null ? void 0 : _a.outerHTML) + "";
  let mounted;
  let dispose;
  return {
    c() {
      td = element("td");
      button = element("button");
      button.disabled = /*disabled*/
      ctx[1];
      attr(button, "class", "small-delete-button svelte-ijdzoh");
      attr(td, "class", "center-td svelte-ijdzoh");
    },
    m(target, anchor) {
      insert(target, td, anchor);
      append(td, button);
      button.innerHTML = raw_value;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*disabled*/
      2) {
        button.disabled = /*disabled*/
        ctx2[1];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(td);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment4(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (!/*altVersion*/
    ctx2[2])
      return create_if_block2;
    if (
      /*status*/
      ctx2[0] === "D"
    )
      return create_if_block_3;
    return create_else_block_1;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function isChecked(e) {
  return e.target.checked;
}
function instance4($$self, $$props, $$invalidate) {
  let { status } = $$props;
  let { disabled = void 0 } = $$props;
  let { altVersion = false } = $$props;
  const dispatch = createEventDispatcher();
  function notifyChange(newStatus) {
    dispatch("statusChange", newStatus);
    $$invalidate(0, status = newStatus);
  }
  const click_handler = () => notifyChange("P");
  const change_handler = (e) => isChecked(e) ? notifyChange("C") : notifyChange("P");
  const click_handler_1 = () => notifyChange("P");
  const click_handler_2 = () => notifyChange("D");
  $$self.$$set = ($$props2) => {
    if ("status" in $$props2)
      $$invalidate(0, status = $$props2.status);
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
    if ("altVersion" in $$props2)
      $$invalidate(2, altVersion = $$props2.altVersion);
  };
  return [
    status,
    disabled,
    altVersion,
    notifyChange,
    click_handler,
    change_handler,
    click_handler_1,
    click_handler_2
  ];
}
var Status = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, { status: 0, disabled: 1, altVersion: 2 }, add_css4);
  }
};
var status_default = Status;

// src/ui/TaskCell.svelte
function add_css5(target) {
  append_styles(target, "svelte-pjd9cm", ".full-width-height.svelte-pjd9cm{width:100%;height:100%}");
}
var get_default_slot_changes = (dirty) => ({});
var get_default_slot_context = (ctx) => ({ class: "full-width-height svelte-pjd9cm" });
function create_fragment5(ctx) {
  let td;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    get_default_slot_context
  );
  return {
    c() {
      td = element("td");
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      insert(target, td, anchor);
      if (default_slot) {
        default_slot.m(td, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(
          td,
          "click",
          /*internalHandleClick*/
          ctx[0]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(td);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { handleClick = () => {
  } } = $$props;
  function internalHandleClick(e) {
    if (!e.target.closest(".no-cell-click")) {
      handleClick(e);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("handleClick" in $$props2)
      $$invalidate(1, handleClick = $$props2.handleClick);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [internalHandleClick, handleClick, $$scope, slots];
}
var TaskCell = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, { handleClick: 1 }, add_css5);
  }
};
var TaskCell_default = TaskCell;

// node_modules/timeago.js/esm/lang/en_US.js
var EN_US = ["second", "minute", "hour", "day", "week", "month", "year"];
function en_US_default(diff, idx) {
  if (idx === 0)
    return ["just now", "right now"];
  var unit = EN_US[Math.floor(idx / 2)];
  if (diff > 1)
    unit += "s";
  return [diff + " " + unit + " ago", "in " + diff + " " + unit];
}

// node_modules/timeago.js/esm/lang/zh_CN.js
var ZH_CN = ["\u79D2", "\u5206\u949F", "\u5C0F\u65F6", "\u5929", "\u5468", "\u4E2A\u6708", "\u5E74"];
function zh_CN_default(diff, idx) {
  if (idx === 0)
    return ["\u521A\u521A", "\u7247\u523B\u540E"];
  var unit = ZH_CN[~~(idx / 2)];
  return [diff + " " + unit + "\u524D", diff + " " + unit + "\u540E"];
}

// node_modules/timeago.js/esm/register.js
var Locales = {};
var register = function(locale, func) {
  Locales[locale] = func;
};
var getLocale = function(locale) {
  return Locales[locale] || Locales["en_US"];
};

// node_modules/timeago.js/esm/utils/date.js
var SEC_ARRAY = [
  60,
  60,
  24,
  7,
  365 / 7 / 12,
  12
];
function toDate(input) {
  if (input instanceof Date)
    return input;
  if (!isNaN(input) || /^\d+$/.test(input))
    return new Date(parseInt(input));
  input = (input || "").trim().replace(/\.\d+/, "").replace(/-/, "/").replace(/-/, "/").replace(/(\d)T(\d)/, "$1 $2").replace(/Z/, " UTC").replace(/([+-]\d\d):?(\d\d)/, " $1$2");
  return new Date(input);
}
function formatDiff(diff, localeFunc) {
  var agoIn = diff < 0 ? 1 : 0;
  diff = Math.abs(diff);
  var totalSec = diff;
  var idx = 0;
  for (; diff >= SEC_ARRAY[idx] && idx < SEC_ARRAY.length; idx++) {
    diff /= SEC_ARRAY[idx];
  }
  diff = Math.floor(diff);
  idx *= 2;
  if (diff > (idx === 0 ? 9 : 1))
    idx += 1;
  return localeFunc(diff, idx, totalSec)[agoIn].replace("%s", diff.toString());
}
function diffSec(date, relativeDate) {
  var relDate = relativeDate ? toDate(relativeDate) : new Date();
  return (+relDate - +toDate(date)) / 1e3;
}

// node_modules/timeago.js/esm/format.js
var format = function(date, locale, opts) {
  var sec = diffSec(date, opts && opts.relativeDate);
  return formatDiff(sec, getLocale(locale));
};

// node_modules/timeago.js/esm/index.js
register("en_US", en_US_default);
register("zh_CN", zh_CN_default);

// src/ui/col/tags.svelte
var import_crypto2 = require("crypto");
function add_css6(target) {
  append_styles(target, "svelte-rrjofn", ".pill-container.svelte-rrjofn{display:flex;flex-wrap:wrap;justify-content:center}.accent-1.svelte-rrjofn{color:var(--color-red);background-color:rgba(var(--color-red-rgb), 0.1)}.accent-2.svelte-rrjofn{color:var(--color-orange);background-color:rgba(var(--color-orange-rgb), 0.1)}.accent-3.svelte-rrjofn{color:var(--color-yellow);background-color:rgba(var(--color-yellow-rgb), 0.1)}.accent-4.svelte-rrjofn{color:var(--color-green);background-color:rgba(var(--color-green-rgb), 0.1)}.accent-5.svelte-rrjofn{color:var(--color-cyan);background-color:rgba(var(--color-cyan-rgb), 0.1)}.accent-6.svelte-rrjofn{color:var(--color-blue);background-color:rgba(var(--color-blue-rgb), 0.1)}.pill-class.svelte-rrjofn{display:inline-flex;align-items:center;padding:0.25em 0.25em;margin:0.1em;border-radius:var(--pill-radius);font-weight:var(--pill-weight);font-size:var(--metadata-input-font-size);justify-content:center}.delete-button.svelte-rrjofn{background:none;border:none;padding:0 0.1em;cursor:pointer;font-size:1.2em;line-height:0.85;opacity:0.7;color:inherit;display:flex;align-items:center;height:100%;border:0;box-shadow:none;height:auto}.delete-button.svelte-rrjofn:hover{opacity:1}.center-td.svelte-rrjofn{text-align:center}");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  return child_ctx;
}
function create_if_block3(ctx) {
  let div;
  let each_value = ensure_array_like(
    /*tagsArr*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "pill-container svelte-rrjofn");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*textToId6, tagsArr, removeTag*/
      7) {
        each_value = ensure_array_like(
          /*tagsArr*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block3(ctx) {
  let div;
  let button;
  let t0;
  let button_aria_label_value;
  let t1;
  let t2_value = (
    /*tag*/
    ctx[8] + ""
  );
  let t2;
  let t3;
  let div_class_value;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[5](
        /*tag*/
        ctx[8]
      )
    );
  }
  return {
    c() {
      div = element("div");
      button = element("button");
      t0 = text("\xD7");
      t1 = space();
      t2 = text(t2_value);
      t3 = space();
      attr(button, "class", "delete-button svelte-rrjofn");
      attr(button, "aria-label", button_aria_label_value = `Remove ${/*tag*/
      ctx[8]}`);
      attr(div, "class", div_class_value = `pill-class accent-${/*textToId6*/
      ctx[1](
        /*tag*/
        ctx[8]
      ) + 1} no-cell-click svelte-rrjofn`);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      append(button, t0);
      append(div, t1);
      append(div, t2);
      append(div, t3);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*tagsArr*/
      1 && button_aria_label_value !== (button_aria_label_value = `Remove ${/*tag*/
      ctx[8]}`)) {
        attr(button, "aria-label", button_aria_label_value);
      }
      if (dirty & /*tagsArr*/
      1 && t2_value !== (t2_value = /*tag*/
      ctx[8] + ""))
        set_data(t2, t2_value);
      if (dirty & /*tagsArr*/
      1 && div_class_value !== (div_class_value = `pill-class accent-${/*textToId6*/
      ctx[1](
        /*tag*/
        ctx[8]
      ) + 1} no-cell-click svelte-rrjofn`)) {
        attr(div, "class", div_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment6(ctx) {
  let div;
  let if_block = (
    /*tagsArr*/
    ctx[0].length !== 0 && create_if_block3(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "center-td svelte-rrjofn");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
    },
    p(ctx2, [dirty]) {
      if (
        /*tagsArr*/
        ctx2[0].length !== 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  const plugin = getGlobalContext();
  let disabled = false;
  let { tags } = $$props;
  let { uuid } = $$props;
  let tagsArr;
  function textToId6(text2) {
    return (0, import_crypto2.createHash)("sha1").update(text2).digest().readUint8(0) % 6;
  }
  async function removeTag(tag) {
    disabled = true;
    await plugin.handler.removeTag(uuid, tag).catch((err2) => {
      disabled = false;
      plugin.logger.debug_log(`Error removing tag ${tag} from task ${uuid}`, err2);
    });
    disabled = false;
  }
  const click_handler = (tag) => {
    removeTag(tag);
  };
  $$self.$$set = ($$props2) => {
    if ("tags" in $$props2)
      $$invalidate(3, tags = $$props2.tags);
    if ("uuid" in $$props2)
      $$invalidate(4, uuid = $$props2.uuid);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*tags*/
    8) {
      $: {
        $$invalidate(0, tagsArr = tags ? tags.split(" ") : []);
      }
    }
  };
  return [tagsArr, textToId6, removeTag, tags, uuid, click_handler];
}
var Tags = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance6, create_fragment6, safe_not_equal, { tags: 3, uuid: 4 }, add_css6);
  }
};
var tags_default = Tags;

// src/ui/col/urgency.svelte
function add_css7(target) {
  append_styles(target, "svelte-l4yssk", ".pill-container.svelte-l4yssk{display:flex;flex-wrap:wrap;justify-content:center}.pill-class.svelte-l4yssk{display:inline-block;padding:0.25em 0.25em;margin:0.1em;border-radius:var(--pill-radius);font-weight:var(--pill-weight);font-size:var(--metadata-input-font-size);justify-content:center}.center-td.svelte-l4yssk{text-align:center}");
}
function create_fragment7(ctx) {
  let div2;
  let div1;
  let div0;
  let t;
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      t = text(
        /*urgency*/
        ctx[0]
      );
      set_style(div0, "color", colorHSLToString(
        /*urgencyColor*/
        ctx[1]
      ));
      set_style(div0, "background-color", colorHSLToString(
        /*urgencyColor*/
        ctx[1],
        0.1
      ));
      attr(div0, "class", "pill-class svelte-l4yssk");
      attr(div1, "class", "pill-container svelte-l4yssk");
      attr(div2, "class", "center-td svelte-l4yssk");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      append(div0, t);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*urgency*/
      1)
        set_data(
          t,
          /*urgency*/
          ctx2[0]
        );
      if (dirty & /*urgencyColor*/
      2) {
        set_style(div0, "color", colorHSLToString(
          /*urgencyColor*/
          ctx2[1]
        ));
      }
      if (dirty & /*urgencyColor*/
      2) {
        set_style(div0, "background-color", colorHSLToString(
          /*urgencyColor*/
          ctx2[1],
          0.1
        ));
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
function colorHSLToString(color, alpha = 1) {
  return `hsla(${color[0]}, ${color[1]}%, ${color[2]}%, ${alpha})`;
}
function instance7($$self, $$props, $$invalidate) {
  let { urgency } = $$props;
  let aColorHSL = memoizedHexToHSL(document.body.getCssPropertyValue("--color-red"));
  let bColorHSL = memoizedHexToHSL(document.body.getCssPropertyValue("--color-yellow"));
  let cColorHSL = memoizedHexToHSL(document.body.getCssPropertyValue("--color-green"));
  let urgencyValue;
  let urgencyColor;
  onMount(() => {
    $$invalidate(2, urgencyValue = parseFloat(urgency) / 10);
    $$invalidate(1, urgencyColor = threeColorHslLerp(cColorHSL, bColorHSL, aColorHSL, urgencyValue));
  });
  $$self.$$set = ($$props2) => {
    if ("urgency" in $$props2)
      $$invalidate(0, urgency = $$props2.urgency);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*urgency*/
    1) {
      $: {
        $$invalidate(2, urgencyValue = (parseFloat(urgency) + 5) / 20);
      }
    }
    if ($$self.$$.dirty & /*urgencyValue*/
    4) {
      $: {
        $$invalidate(1, urgencyColor = threeColorHslLerp(cColorHSL, bColorHSL, aColorHSL, urgencyValue));
      }
    }
  };
  return [urgency, urgencyColor, urgencyValue];
}
var Urgency = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment7, safe_not_equal, { urgency: 0 }, add_css7);
  }
};
var urgency_default = Urgency;

// src/ui/col/projects.svelte
var import_crypto3 = require("crypto");
function add_css8(target) {
  append_styles(target, "svelte-1oue4a4", ".accent-1.svelte-1oue4a4.svelte-1oue4a4{color:var(--color-red)}.accent-2.svelte-1oue4a4.svelte-1oue4a4{color:var(--color-orange)}.accent-3.svelte-1oue4a4.svelte-1oue4a4{color:var(--color-yellow)}.accent-4.svelte-1oue4a4.svelte-1oue4a4{color:var(--color-green)}.accent-5.svelte-1oue4a4.svelte-1oue4a4{color:var(--color-cyan)}.accent-6.svelte-1oue4a4.svelte-1oue4a4{color:var(--color-blue)}.pill-class.svelte-1oue4a4 a.svelte-1oue4a4{color:inherit;text-decoration:none}.pill-class.svelte-1oue4a4 a.svelte-1oue4a4:hover{text-decoration:underline}.pill-class.svelte-1oue4a4.svelte-1oue4a4{display:inline-block;padding:0.25em 0.25em;margin:0.1em;font-size:var(--metadata-input-font-size);justify-content:left}.center-td.svelte-1oue4a4.svelte-1oue4a4{text-align:left}");
}
function create_if_block4(ctx) {
  let div;
  let div_class_value;
  function select_block_type(ctx2, dirty) {
    if (
      /*uri*/
      ctx2[1]
    )
      return create_if_block_12;
    return create_else_block2;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", div_class_value = `pill-class accent-${/*textToId6*/
      ctx[2](
        /*project*/
        ctx[0]
      ) + 1} svelte-1oue4a4`);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if_block.p(ctx2, dirty);
      if (dirty & /*project*/
      1 && div_class_value !== (div_class_value = `pill-class accent-${/*textToId6*/
      ctx2[2](
        /*project*/
        ctx2[0]
      ) + 1} svelte-1oue4a4`)) {
        attr(div, "class", div_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_block.d();
    }
  };
}
function create_else_block2(ctx) {
  let t;
  return {
    c() {
      t = text(
        /*project*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*project*/
      1)
        set_data(
          t,
          /*project*/
          ctx2[0]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_12(ctx) {
  let a;
  let t;
  return {
    c() {
      a = element("a");
      t = text(
        /*project*/
        ctx[0]
      );
      attr(a, "class", "no-cell-click svelte-1oue4a4");
      attr(
        a,
        "href",
        /*uri*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*project*/
      1)
        set_data(
          t,
          /*project*/
          ctx2[0]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(a);
      }
    }
  };
}
function create_fragment8(ctx) {
  let div;
  let if_block = (
    /*project*/
    ctx[0] && create_if_block4(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "center-td svelte-1oue4a4");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
    },
    p(ctx2, [dirty]) {
      if (
        /*project*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function instance8($$self, $$props, $$invalidate) {
  let { project } = $$props;
  const plugin = getGlobalContext();
  const uri = project ? matchProjectRegex(project) : void 0;
  function textToId6(text2) {
    return (0, import_crypto3.createHash)("sha1").update(text2).digest().readUint8(0) % 6;
  }
  $$self.$$set = ($$props2) => {
    if ("project" in $$props2)
      $$invalidate(0, project = $$props2.project);
  };
  return [project, uri, textToId6];
}
var Projects = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance8, create_fragment8, safe_not_equal, { project: 0 }, add_css8);
  }
};
var projects_default = Projects;

// src/ui/col/active.svelte
function add_css9(target) {
  append_styles(target, "svelte-3g3dtp", ".small-checkbox.svelte-3g3dtp{margin:0}.center-div.svelte-3g3dtp{text-align:center}");
}
function create_fragment9(ctx) {
  let div;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      input.disabled = /*disabled*/
      ctx[0];
      attr(input, "class", "small-checkbox no-cell-click svelte-3g3dtp");
      attr(input, "type", "checkbox");
      input.checked = /*taskActive*/
      ctx[1];
      attr(div, "class", "center-div svelte-3g3dtp");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*change_handler*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*disabled*/
      1) {
        input.disabled = /*disabled*/
        ctx2[0];
      }
      if (dirty & /*taskActive*/
      2) {
        input.checked = /*taskActive*/
        ctx2[1];
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function isChecked2(e) {
  return e.target.checked;
}
function instance9($$self, $$props, $$invalidate) {
  const plugin = getGlobalContext();
  let { uuid } = $$props;
  let { taskActive } = $$props;
  let { disabled = void 0 } = $$props;
  async function changeActiveStatus(newStatus) {
    $$invalidate(0, disabled = true);
    const result = await (newStatus ? plugin.handler.stopTask(uuid) : plugin.handler.startTask(uuid));
    $$invalidate(0, disabled = void 0);
  }
  const change_handler = (e) => isChecked2(e) ? changeActiveStatus(false) : changeActiveStatus(true);
  $$self.$$set = ($$props2) => {
    if ("uuid" in $$props2)
      $$invalidate(3, uuid = $$props2.uuid);
    if ("taskActive" in $$props2)
      $$invalidate(1, taskActive = $$props2.taskActive);
    if ("disabled" in $$props2)
      $$invalidate(0, disabled = $$props2.disabled);
  };
  return [disabled, taskActive, changeActiveStatus, uuid, change_handler];
}
var Active = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance9, create_fragment9, safe_not_equal, { uuid: 3, taskActive: 1, disabled: 0 }, add_css9);
  }
};
var active_default = Active;

// src/ui/TaskList.svelte
function add_css10(target) {
  append_styles(target, "svelte-n5gjaq", ".loader.svelte-n5gjaq.svelte-n5gjaq{padding:4px;display:flex;justify-content:space-between;align-items:center;background-color:#00000034}.task-hover.svelte-n5gjaq.svelte-n5gjaq:hover{background-color:var(--table-selection)}.padding-horizontal.svelte-n5gjaq.svelte-n5gjaq{padding-left:1em;padding-right:1em}.padder.svelte-n5gjaq.svelte-n5gjaq{padding:8px}.error.svelte-n5gjaq.svelte-n5gjaq{color:lightcoral}.row-disabled.svelte-n5gjaq.svelte-n5gjaq{text-decoration:line-through;color:var(--color-base-50)}.unimportant.svelte-n5gjaq.svelte-n5gjaq{color:var(--color-comment);font-size:var(--font-smallest)}.refresh-container.svelte-n5gjaq.svelte-n5gjaq{display:flex;align-items:center}.report.svelte-n5gjaq.svelte-n5gjaq{padding-left:4px;padding-right:4px}.data.svelte-n5gjaq.svelte-n5gjaq{overflow-x:auto;min-width:none}.tw-table.svelte-n5gjaq.svelte-n5gjaq{width:100%;border-collapse:collapse;margin:0;border:0}.tw-table.svelte-n5gjaq th.svelte-n5gjaq,.tw-table.svelte-n5gjaq .cell-text.svelte-n5gjaq{min-width:1ch !important;font-size:var(--font-smaller)}.text-clickeable.svelte-n5gjaq.svelte-n5gjaq{display:inline-block;cursor:pointer}.text-clickeable.svelte-n5gjaq.svelte-n5gjaq:hover{text-decoration:underline}.refresh-button.svelte-n5gjaq.svelte-n5gjaq{cursor:pointer}.refresh-button.svelte-n5gjaq.svelte-n5gjaq:hover{text-decoration:underline}");
}
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[28] = list[i];
  child_ctx[29] = list;
  child_ctx[30] = i;
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[31] = list[i];
  child_ctx[33] = i;
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[34] = list[i];
  return child_ctx;
}
function create_if_block_11(ctx) {
  var _a;
  let button;
  let raw_value = ((_a = (0, import_obsidian7.getIcon)("plus")) == null ? void 0 : _a.outerHTML) + "";
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      button.innerHTML = raw_value;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[19]
        );
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_10(ctx) {
  let span;
  let t0;
  let t1;
  return {
    c() {
      span = element("span");
      t0 = text("updated ");
      t1 = text(
        /*formattedAgo*/
        ctx[7]
      );
      attr(span, "class", "report unimportant padding-horizontal svelte-n5gjaq");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*formattedAgo*/
      128)
        set_data(
          t1,
          /*formattedAgo*/
          ctx2[7]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_9(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "error fetching tasks";
      attr(span, "class", "report unimportant error padding-horizontal svelte-n5gjaq");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_8(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "loading...";
      attr(span, "class", "report unimportant padding-horizontal svelte-n5gjaq");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block5(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_13, create_if_block_22, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*reportList*/
      ctx2[4].columns.length <= 2
    )
      return 0;
    if (
      /*reportList*/
      ctx2[4].tasks.length === 0
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block3(ctx) {
  let table;
  let thead;
  let tr;
  let th;
  let t0;
  let t1;
  let tbody;
  let each_blocks = [];
  let each1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value_2 = ensure_array_like(
    /*reportList*/
    ctx[4].printedColumns
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks_1[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  let each_value = ensure_array_like(
    /*reportList*/
    ctx[4].tasks
  );
  const get_key = (ctx2) => (
    /*task*/
    ctx2[28].uuid
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context4(ctx, each_value, i);
    let key = get_key(child_ctx);
    each1_lookup.set(key, each_blocks[i] = create_each_block4(key, child_ctx));
  }
  return {
    c() {
      table = element("table");
      thead = element("thead");
      tr = element("tr");
      th = element("th");
      t0 = space();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t1 = space();
      tbody = element("tbody");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(th, "class", "svelte-n5gjaq");
      attr(table, "class", "tw-table svelte-n5gjaq");
    },
    m(target, anchor) {
      insert(target, table, anchor);
      append(table, thead);
      append(thead, tr);
      append(tr, th);
      append(tr, t0);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(tr, null);
        }
      }
      append(table, t1);
      append(table, tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tbody, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*reportList*/
      16) {
        each_value_2 = ensure_array_like(
          /*reportList*/
          ctx2[4].printedColumns
        );
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_2(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(tr, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_2.length;
      }
      if (dirty[0] & /*reportList, plugin, newUpdateModal, deleteKeyDown, handleStatusChange*/
      9520) {
        each_value = ensure_array_like(
          /*reportList*/
          ctx2[4].tasks
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each1_lookup, tbody, outro_and_destroy_block, create_each_block4, null, get_each_context4);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(table);
      }
      destroy_each(each_blocks_1, detaching);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function create_if_block_22(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<span>No tasks found in report.</span>`;
      attr(div, "class", "padder error svelte-n5gjaq");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_13(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<span>Report does not seem to exist.</span>`;
      attr(div, "class", "padder error svelte-n5gjaq");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_each_block_2(ctx) {
  let th;
  let t_value = (
    /*pColumns*/
    ctx[34].label + ""
  );
  let t;
  return {
    c() {
      th = element("th");
      t = text(t_value);
      attr(th, "class", "svelte-n5gjaq");
    },
    m(target, anchor) {
      insert(target, th, anchor);
      append(th, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*reportList*/
      16 && t_value !== (t_value = /*pColumns*/
      ctx2[34].label + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(th);
      }
    }
  };
}
function create_else_block_12(ctx) {
  let span;
  let t_value = (
    /*data*/
    ctx[31] + ""
  );
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "cell-text svelte-n5gjaq");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*reportList*/
      16 && t_value !== (t_value = /*data*/
      ctx2[31] + ""))
        set_data(t, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_7(ctx) {
  let project;
  let current;
  project = new projects_default({ props: { project: (
    /*data*/
    ctx[31]
  ) } });
  return {
    c() {
      create_component(project.$$.fragment);
    },
    m(target, anchor) {
      mount_component(project, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const project_changes = {};
      if (dirty[0] & /*reportList*/
      16)
        project_changes.project = /*data*/
        ctx2[31];
      project.$set(project_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(project.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(project.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(project, detaching);
    }
  };
}
function create_if_block_6(ctx) {
  let active;
  let current;
  active = new active_default({
    props: {
      uuid: (
        /*task*/
        ctx[28].uuid
      ),
      taskActive: (
        /*data*/
        ctx[31] === "*"
      ),
      disabled: (
        /*task*/
        ctx[28].disabled
      )
    }
  });
  return {
    c() {
      create_component(active.$$.fragment);
    },
    m(target, anchor) {
      mount_component(active, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const active_changes = {};
      if (dirty[0] & /*reportList*/
      16)
        active_changes.uuid = /*task*/
        ctx2[28].uuid;
      if (dirty[0] & /*reportList*/
      16)
        active_changes.taskActive = /*data*/
        ctx2[31] === "*";
      if (dirty[0] & /*reportList*/
      16)
        active_changes.disabled = /*task*/
        ctx2[28].disabled;
      active.$set(active_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(active.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(active.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(active, detaching);
    }
  };
}
function create_if_block_5(ctx) {
  let urgency;
  let current;
  urgency = new urgency_default({ props: { urgency: (
    /*data*/
    ctx[31]
  ) } });
  return {
    c() {
      create_component(urgency.$$.fragment);
    },
    m(target, anchor) {
      mount_component(urgency, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const urgency_changes = {};
      if (dirty[0] & /*reportList*/
      16)
        urgency_changes.urgency = /*data*/
        ctx2[31];
      urgency.$set(urgency_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(urgency.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(urgency.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(urgency, detaching);
    }
  };
}
function create_if_block_4(ctx) {
  let div;
  let t_value = (
    /*data*/
    ctx[31] + ""
  );
  let t;
  let mounted;
  let dispose;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[22](
        /*task*/
        ctx[28],
        /*data*/
        ctx[31]
      )
    );
  }
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "no-cell-click cell-text text-clickeable svelte-n5gjaq");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
      if (!mounted) {
        dispose = listen(div, "click", click_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*reportList*/
      16 && t_value !== (t_value = /*data*/
      ctx[31] + ""))
        set_data(t, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_32(ctx) {
  let tags;
  let current;
  tags = new tags_default({
    props: {
      uuid: (
        /*task*/
        ctx[28].uuid
      ),
      tags: (
        /*data*/
        ctx[31]
      )
    }
  });
  return {
    c() {
      create_component(tags.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tags, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tags_changes = {};
      if (dirty[0] & /*reportList*/
      16)
        tags_changes.uuid = /*task*/
        ctx2[28].uuid;
      if (dirty[0] & /*reportList*/
      16)
        tags_changes.tags = /*data*/
        ctx2[31];
      tags.$set(tags_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tags.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tags.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tags, detaching);
    }
  };
}
function create_default_slot(ctx) {
  let show_if;
  let show_if_1;
  let show_if_2;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block_32,
    create_if_block_4,
    create_if_block_5,
    create_if_block_6,
    create_if_block_7,
    create_else_block_12
  ];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (dirty[0] & /*reportList*/
    16)
      show_if = null;
    if (dirty[0] & /*reportList*/
    16)
      show_if_1 = null;
    if (dirty[0] & /*reportList*/
    16)
      show_if_2 = null;
    if (
      /*reportList*/
      ctx2[4].printedColumns[
        /*dIndex*/
        ctx2[33]
      ].type === "tags" || /*reportList*/
      ctx2[4].printedColumns[
        /*dIndex*/
        ctx2[33]
      ].type === "tags.list"
    )
      return 0;
    if (show_if == null)
      show_if = !!/*reportList*/
      ctx2[4].printedColumns[
        /*dIndex*/
        ctx2[33]
      ].type.startsWith("description");
    if (show_if)
      return 1;
    if (show_if_1 == null)
      show_if_1 = !!/*reportList*/
      ctx2[4].printedColumns[
        /*dIndex*/
        ctx2[33]
      ].type.startsWith("urgency");
    if (show_if_1)
      return 2;
    if (
      /*reportList*/
      ctx2[4].printedColumns[
        /*dIndex*/
        ctx2[33]
      ].type === "start.active"
    )
      return 3;
    if (show_if_2 == null)
      show_if_2 = !!/*reportList*/
      ctx2[4].printedColumns[
        /*dIndex*/
        ctx2[33]
      ].type.startsWith("project");
    if (show_if_2)
      return 4;
    return 5;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_each_block_1(ctx) {
  let taskcell;
  let current;
  function func() {
    return (
      /*func*/
      ctx[23](
        /*task*/
        ctx[28]
      )
    );
  }
  taskcell = new TaskCell_default({
    props: {
      handleClick: func,
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(taskcell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(taskcell, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const taskcell_changes = {};
      if (dirty[0] & /*reportList*/
      16)
        taskcell_changes.handleClick = func;
      if (dirty[0] & /*reportList*/
      16 | dirty[1] & /*$$scope*/
      64) {
        taskcell_changes.$$scope = { dirty, ctx };
      }
      taskcell.$set(taskcell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(taskcell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(taskcell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(taskcell, detaching);
    }
  };
}
function create_each_block4(key_1, ctx) {
  let tr;
  let status;
  let t0;
  let t1;
  let current;
  let mounted;
  let dispose;
  function statusChange_handler(...args) {
    return (
      /*statusChange_handler*/
      ctx[21](
        /*task*/
        ctx[28],
        /*each_value*/
        ctx[29],
        /*tIndex*/
        ctx[30],
        ...args
      )
    );
  }
  status = new status_default({
    props: {
      disabled: (
        /*task*/
        ctx[28].disabled
      ),
      status: (
        /*task*/
        ctx[28].status
      ),
      altVersion: (
        /*deleteKeyDown*/
        ctx[5]
      )
    }
  });
  status.$on("statusChange", statusChange_handler);
  let each_value_1 = ensure_array_like(
    /*task*/
    ctx[28].data
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  function contextmenu_handler(...args) {
    return (
      /*contextmenu_handler*/
      ctx[24](
        /*task*/
        ctx[28],
        ...args
      )
    );
  }
  return {
    key: key_1,
    first: null,
    c() {
      tr = element("tr");
      create_component(status.$$.fragment);
      t0 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      attr(tr, "class", "task-hover svelte-n5gjaq");
      toggle_class(
        tr,
        "row-disabled",
        /*task*/
        ctx[28].disabled
      );
      this.first = tr;
    },
    m(target, anchor) {
      insert(target, tr, anchor);
      mount_component(status, tr, null);
      append(tr, t0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tr, null);
        }
      }
      append(tr, t1);
      current = true;
      if (!mounted) {
        dispose = listen(tr, "contextmenu", function() {
          if (is_function(
            /*plugin*/
            ctx[8].settings.right_click_context_menu_enabled ? contextmenu_handler : null
          ))
            /*plugin*/
            (ctx[8].settings.right_click_context_menu_enabled ? contextmenu_handler : null).apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const status_changes = {};
      if (dirty[0] & /*reportList*/
      16)
        status_changes.disabled = /*task*/
        ctx[28].disabled;
      if (dirty[0] & /*reportList*/
      16)
        status_changes.status = /*task*/
        ctx[28].status;
      if (dirty[0] & /*deleteKeyDown*/
      32)
        status_changes.altVersion = /*deleteKeyDown*/
        ctx[5];
      status.$set(status_changes);
      if (dirty[0] & /*newUpdateModal, reportList*/
      1040) {
        each_value_1 = ensure_array_like(
          /*task*/
          ctx[28].data
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(tr, t1);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty[0] & /*reportList*/
      16) {
        toggle_class(
          tr,
          "row-disabled",
          /*task*/
          ctx[28].disabled
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(status.$$.fragment, local);
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      transition_out(status.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(tr);
      }
      destroy_component(status);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment10(ctx) {
  var _a;
  let div4;
  let div2;
  let div0;
  let t0;
  let span;
  let t1_value = (
    /*report*/
    ctx[0] + " " + /*command*/
    ctx[1]
  );
  let t1;
  let t2;
  let div1;
  let t3;
  let t4;
  let t5;
  let button;
  let raw_value = ((_a = (0, import_obsidian7.getIcon)("rotate-cw")) == null ? void 0 : _a.outerHTML) + "";
  let t6;
  let div3;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*newTaskTemplate*/
    ctx[2] && create_if_block_11(ctx)
  );
  let if_block1 = (
    /*state*/
    ctx[3] === "ok" && create_if_block_10(ctx)
  );
  let if_block2 = (
    /*state*/
    ctx[3] === "error" && create_if_block_9(ctx)
  );
  let if_block3 = (
    /*state*/
    ctx[3] === "loading" && create_if_block_8(ctx)
  );
  let if_block4 = (
    /*reportList*/
    ctx[4] !== void 0 && create_if_block5(ctx)
  );
  return {
    c() {
      div4 = element("div");
      div2 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      t2 = space();
      div1 = element("div");
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      t4 = space();
      if (if_block3)
        if_block3.c();
      t5 = space();
      button = element("button");
      t6 = space();
      div3 = element("div");
      if (if_block4)
        if_block4.c();
      attr(span, "class", "unimportant padding-horizontal svelte-n5gjaq");
      attr(div0, "class", "refresh-container svelte-n5gjaq");
      attr(button, "class", "refresh-button svelte-n5gjaq");
      attr(div1, "class", "refresh-container svelte-n5gjaq");
      attr(div2, "class", "loader svelte-n5gjaq");
      attr(div3, "class", "data svelte-n5gjaq");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div2);
      append(div2, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t0);
      append(div0, span);
      append(span, t1);
      append(div2, t2);
      append(div2, div1);
      if (if_block1)
        if_block1.m(div1, null);
      append(div1, t3);
      if (if_block2)
        if_block2.m(div1, null);
      append(div1, t4);
      if (if_block3)
        if_block3.m(div1, null);
      append(div1, t5);
      append(div1, button);
      button.innerHTML = raw_value;
      ctx[20](button);
      append(div4, t6);
      append(div4, div3);
      if (if_block4)
        if_block4.m(div3, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            window,
            "keydown",
            /*keydown_handler*/
            ctx[17]
          ),
          listen(
            window,
            "keyup",
            /*keyup_handler*/
            ctx[18]
          ),
          listen(
            button,
            "click",
            /*getTasks*/
            ctx[9]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (
        /*newTaskTemplate*/
        ctx2[2]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_11(ctx2);
          if_block0.c();
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if ((!current || dirty[0] & /*report, command*/
      3) && t1_value !== (t1_value = /*report*/
      ctx2[0] + " " + /*command*/
      ctx2[1]))
        set_data(t1, t1_value);
      if (
        /*state*/
        ctx2[3] === "ok"
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_10(ctx2);
          if_block1.c();
          if_block1.m(div1, t3);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*state*/
        ctx2[3] === "error"
      ) {
        if (if_block2) {
        } else {
          if_block2 = create_if_block_9(ctx2);
          if_block2.c();
          if_block2.m(div1, t4);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*state*/
        ctx2[3] === "loading"
      ) {
        if (if_block3) {
        } else {
          if_block3 = create_if_block_8(ctx2);
          if_block3.c();
          if_block3.m(div1, t5);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (
        /*reportList*/
        ctx2[4] !== void 0
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[0] & /*reportList*/
          16) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block5(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div3, null);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block4);
      current = true;
    },
    o(local) {
      transition_out(if_block4);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      ctx[20](null);
      if (if_block4)
        if_block4.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance10($$self, $$props, $$invalidate) {
  let { report } = $$props;
  let { sanitizedReport } = $$props;
  let { command } = $$props;
  let { sanitizedCommand } = $$props;
  let { newTaskTemplate } = $$props;
  const plugin = getGlobalContext();
  let state = "loading";
  let reportList;
  let timestamp;
  let deleteKeyDown = false;
  let refreshButton;
  let formattedAgo;
  function formatTimestamp(timestamp2) {
    $$invalidate(7, formattedAgo = format(timestamp2));
  }
  async function getTasks() {
    var _a;
    $$invalidate(3, state = "loading");
    let result;
    try {
      result = await ((_a = plugin.handler) === null || _a === void 0 ? void 0 : _a.getTasks(sanitizedReport, sanitizedCommand));
    } catch (error) {
      $$invalidate(3, state = "error");
      plugin.logger.debug_log("Error fetching tasks", error);
      return;
    }
    $$invalidate(4, reportList = result.report);
    $$invalidate(16, timestamp = result.timestamp);
    $$invalidate(3, state = "ok");
  }
  function newUpdateModal(task, value) {
    return new UpdateTaskModal({ uuid: task.uuid }, { value });
  }
  function onDeleteKeyDown() {
    $$invalidate(5, deleteKeyDown = true);
  }
  function onDeleteKeyUp() {
    $$invalidate(5, deleteKeyDown = false);
  }
  async function handleStatusChange(uuid, e) {
    var _a, _b, _c, _d;
    switch (e.detail) {
      case "C":
        await ((_a = plugin.handler) === null || _a === void 0 ? void 0 : _a.completeTask(uuid));
        break;
      case "D":
        await ((_b = plugin.handler) === null || _b === void 0 ? void 0 : _b.deleteTask(uuid));
        break;
      case "P":
        await ((_c = plugin.handler) === null || _c === void 0 ? void 0 : _c.modifyTask(uuid, "status:pending"));
        break;
      case "R":
        await ((_d = plugin.handler) === null || _d === void 0 ? void 0 : _d.modifyTask(uuid, "status:recurring"));
        break;
      default:
        break;
    }
  }
  const refreshCallback = () => {
    getTasks();
  };
  const intervalCallback = () => {
    formatTimestamp(timestamp);
  };
  onMount(() => {
    var _a, _b;
    getTasks();
    (_a = plugin.emitter) === null || _a === void 0 ? void 0 : _a.on("pending-refresh" /* REFRESH */, refreshCallback);
    (_b = plugin.emitter) === null || _b === void 0 ? void 0 : _b.on("interval-fetch" /* INTERVAL */, intervalCallback);
  });
  onDestroy(() => {
    var _a, _b;
    (_a = plugin.emitter) === null || _a === void 0 ? void 0 : _a.off("pending-refresh" /* REFRESH */, refreshCallback);
    (_b = plugin.emitter) === null || _b === void 0 ? void 0 : _b.off("interval-fetch" /* INTERVAL */, intervalCallback);
  });
  const keydown_handler2 = (e) => e.key === plugin.settings.delete_key && onDeleteKeyDown();
  const keyup_handler = (e) => e.key === plugin.settings.delete_key && onDeleteKeyUp();
  const click_handler = () => new CreateTaskModal(newTaskTemplate).open();
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      refreshButton = $$value;
      $$invalidate(6, refreshButton);
    });
  }
  const statusChange_handler = (task, each_value, tIndex, e) => {
    handleStatusChange(task.uuid, e);
    $$invalidate(4, each_value[tIndex].disabled = true, reportList);
  };
  const click_handler_1 = (task, data) => {
    newUpdateModal(task, data).open();
  };
  const func = (task) => {
    newUpdateModal(task).open();
  };
  const contextmenu_handler = (task, event) => showActionMenu(task.uuid, event, plugin);
  $$self.$$set = ($$props2) => {
    if ("report" in $$props2)
      $$invalidate(0, report = $$props2.report);
    if ("sanitizedReport" in $$props2)
      $$invalidate(14, sanitizedReport = $$props2.sanitizedReport);
    if ("command" in $$props2)
      $$invalidate(1, command = $$props2.command);
    if ("sanitizedCommand" in $$props2)
      $$invalidate(15, sanitizedCommand = $$props2.sanitizedCommand);
    if ("newTaskTemplate" in $$props2)
      $$invalidate(2, newTaskTemplate = $$props2.newTaskTemplate);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*timestamp*/
    65536) {
      $: {
        formatTimestamp(timestamp);
      }
    }
  };
  return [
    report,
    command,
    newTaskTemplate,
    state,
    reportList,
    deleteKeyDown,
    refreshButton,
    formattedAgo,
    plugin,
    getTasks,
    newUpdateModal,
    onDeleteKeyDown,
    onDeleteKeyUp,
    handleStatusChange,
    sanitizedReport,
    sanitizedCommand,
    timestamp,
    keydown_handler2,
    keyup_handler,
    click_handler,
    button_binding,
    statusChange_handler,
    click_handler_1,
    func,
    contextmenu_handler
  ];
}
var TaskList = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance10,
      create_fragment10,
      safe_not_equal,
      {
        report: 0,
        sanitizedReport: 14,
        command: 1,
        sanitizedCommand: 15,
        newTaskTemplate: 2
      },
      add_css10,
      [-1, -1]
    );
  }
};
var TaskList_default = TaskList;

// src/main.ts
var import_tiny_emitter = __toESM(require_tiny_emitter());
var import_crypto4 = require("crypto");
var RightClickMenuAction = class {
  constructor(name, action) {
    this.Action = action;
    this.ActionName = name;
    this.ActionId = (0, import_crypto4.randomUUID)();
  }
};
var ProjectRegexUrl = class {
  constructor(regex, uri) {
    this.regexString = regex;
    this.uri = uri;
  }
};
var DEFAULT_SETTINGS = {
  tw_bin: "task",
  debug_log: false,
  cache_columns: true,
  delete_key: "Alt",
  right_click_context_menu_enabled: false,
  right_click_context_menu_actions: [],
  project_urls_enabled: false,
  project_regex_url_entries: []
};
var LifeCycleHookMRC = class extends import_obsidian8.MarkdownRenderChild {
  constructor(el, component) {
    super(el);
    this.component = component;
  }
  onunload() {
    this.component.$destroy();
  }
};
var TWPlugin = class extends import_obsidian8.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
    this.emitter = void 0;
    this.handler = void 0;
    this.logger = void 0;
  }
  async onload() {
    await this.loadSettings();
    this.emitter = new import_tiny_emitter.TinyEmitter();
    this.handler = new TaskHandler(this);
    this.logger = new TWPluginLogger(this.settings.debug_log);
    this.addCommand({
      id: "create-new-task",
      name: "Create task",
      callback: () => {
        new CreateTaskModal().open();
      }
    });
    this.addCommand({
      id: "undo",
      name: "Undo last task action",
      callback: () => {
        var _a;
        (_a = this.handler) == null ? void 0 : _a.undo();
      }
    });
    this.registerMarkdownCodeBlockProcessor("tw", (source, el, ctx) => {
      var _a, _b, _c;
      const input = source.trim().split("\n");
      const report = (_a = input[0]) == null ? void 0 : _a.trim();
      const command = (_b = input[1]) == null ? void 0 : _b.trim();
      const newTaskTemplate = (_c = input[2]) == null ? void 0 : _c.trim();
      setGlobalContext(this);
      const svelteComponent = new TaskList_default({
        target: el,
        props: {
          report,
          sanitizedReport: sanitizeSingleArgument(report),
          command,
          sanitizedCommand: command ? sanitize(command) : "",
          newTaskTemplate
        }
      });
      const component = new LifeCycleHookMRC(el, svelteComponent);
      ctx.addChild(component);
    });
    this.registerInterval(window.setInterval(() => {
      var _a;
      return (_a = this.emitter) == null ? void 0 : _a.emit("interval-fetch" /* INTERVAL */);
    }, 1e4));
    this.addSettingTab(new TWSettingTab(this.app, this));
  }
  onunload() {
    var _a, _b;
    (_a = this.emitter) == null ? void 0 : _a.off("interval-fetch" /* INTERVAL */);
    (_b = this.emitter) == null ? void 0 : _b.off("pending-refresh" /* REFRESH */);
    this.emitter = void 0;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var TWSettingTab = class extends import_obsidian8.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian8.Setting(containerEl).setName("TaskWarrior path").setDesc("Path of the taskwarrior executable").addText((text2) => text2.setPlaceholder("/usr/bin/task").setValue(this.plugin.settings.tw_bin).onChange(async (value) => {
      this.plugin.settings.tw_bin = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Debug log").setDesc("Enable debug logging. Prints taskwarrior commands to web console.").addToggle((toggle) => toggle.setValue(this.plugin.settings.debug_log).onChange(async (value) => {
      var _a;
      this.plugin.settings.debug_log = value;
      (_a = this.plugin.logger) == null ? void 0 : _a.setDebugMode(value);
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Columns cache").setDesc("Cache report columns/labels for faster reloading. Disable if you fiddle with the taskwarrior report columns too much :).").addButton((button) => {
      button.setButtonText("Clear cache").onClick(async () => {
        var _a;
        const cleared = (_a = this.plugin.handler) == null ? void 0 : _a.clearColumnCache();
        if (cleared !== void 0)
          new import_obsidian8.Notice(`Cleared ${cleared} cached reports`);
      });
    }).addToggle((toggle) => toggle.setValue(this.plugin.settings.cache_columns).onChange(async (value) => {
      this.plugin.settings.cache_columns = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Deletion hold Key").setDesc("Hold key to enable task deletion").addText((text2) => text2.setPlaceholder("Alt").setValue(this.plugin.settings.delete_key).onChange(async (value) => {
      this.plugin.settings.delete_key = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian8.Setting(containerEl).setName("Enable custom actions context menu").setDesc("Will enable feature of custom actions on context menu on right click.").addToggle((toggle) => toggle.setValue(this.plugin.settings.right_click_context_menu_enabled).onChange(async (value) => {
      this.plugin.settings.right_click_context_menu_enabled = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.right_click_context_menu_enabled) {
      new import_obsidian8.Setting(containerEl).setHeading().setName("Right click context menu actions").setDesc("").addButton((button) => {
        button.setButtonText("+").onClick(async () => {
          this.plugin.settings.right_click_context_menu_actions.push(new RightClickMenuAction("", ""));
          this.display();
        });
      });
      for (const [index, action] of this.plugin.settings.right_click_context_menu_actions.entries()) {
        new import_obsidian8.Setting(containerEl).addText((text2) => text2.setPlaceholder("Name").setValue(action.ActionName).onChange(async (value) => {
          this.plugin.settings.right_click_context_menu_actions[index].ActionName = value;
          await this.plugin.saveSettings();
        })).addText((text2) => text2.setPlaceholder("Example +today").setValue(action.Action).onChange(async (value) => {
          this.plugin.settings.right_click_context_menu_actions[index].Action = value;
          await this.plugin.saveSettings();
        })).addButton((button) => {
          button.setButtonText("-").onClick(async () => {
            this.plugin.settings.right_click_context_menu_actions = this.plugin.settings.right_click_context_menu_actions.filter((x) => x.ActionId != action.ActionId);
            await this.plugin.saveSettings();
            this.display();
          });
        });
      }
    }
    new import_obsidian8.Setting(containerEl).setName("Enable project urls").setDesc("Will enable external linking for projects in lists.").addToggle((toggle) => toggle.setValue(this.plugin.settings.project_urls_enabled).onChange(async (value) => {
      this.plugin.settings.project_urls_enabled = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.project_urls_enabled) {
      new import_obsidian8.Setting(containerEl).setHeading().setName("Project Regex URIs").setDesc("Order dictates priority").addButton((button) => {
        button.setButtonText("+").onClick(async () => {
          this.plugin.settings.project_regex_url_entries.push(new ProjectRegexUrl("", ""));
          this.display();
        });
      });
      for (const [index, project] of this.plugin.settings.project_regex_url_entries.entries()) {
        new import_obsidian8.Setting(containerEl).addText((text2) => text2.setPlaceholder("myproject.*").setValue(project.regexString).onChange(async (value) => {
          this.plugin.settings.project_regex_url_entries[index].regexString = value;
          clearUriCache();
          await this.plugin.saveSettings();
        })).addText((text2) => text2.setPlaceholder("obsidian://myfolder/mysubfolder/myproject").setValue(project.uri).onChange(async (value) => {
          this.plugin.settings.project_regex_url_entries[index].uri = value;
          clearUriCache();
          await this.plugin.saveSettings();
        })).addButton((button) => {
          button.setButtonText("\u2191").onClick(async () => {
            if (index > 0) {
              const temp = this.plugin.settings.project_regex_url_entries[index - 1];
              this.plugin.settings.project_regex_url_entries[index - 1] = this.plugin.settings.project_regex_url_entries[index];
              this.plugin.settings.project_regex_url_entries[index] = temp;
              clearUriCache();
              await this.plugin.saveSettings();
              this.display();
            }
          });
        }).addButton((button) => {
          button.setButtonText("\u2193").onClick(async () => {
            if (index < this.plugin.settings.project_regex_url_entries.length - 1) {
              const temp = this.plugin.settings.project_regex_url_entries[index + 1];
              this.plugin.settings.project_regex_url_entries[index + 1] = this.plugin.settings.project_regex_url_entries[index];
              this.plugin.settings.project_regex_url_entries[index] = temp;
              clearUriCache();
              await this.plugin.saveSettings();
              this.display();
            }
          });
        }).addButton((button) => {
          button.setButtonText("-").onClick(async () => {
            this.plugin.settings.project_regex_url_entries = this.plugin.settings.project_regex_url_entries.filter((x) => x != project);
            clearUriCache();
            await this.plugin.saveSettings();
            this.display();
          });
        });
      }
    }
  }
};

/* nosourcemap */